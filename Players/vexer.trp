{
Program: Vexer
Author: Nathan Scarbrough
Email: Nathan.Scarbrough@gmail.com (Please send error files directly to me)

Description: Vexer's has two strategies:
1. When Card Turn In Value (CTIV) is based on progression:
  - take out weak players for their cards
2. Vexer doesn't yet play to win when CTIV is based on combination, that strategy is still in development. Instead, he is more of a menace, e.g. killing off weak players and attacking continents to prevent bonuses.

If the preset level "Very Hard" isn't hard enough, try adding another Vexer.

History: Version 0.9 August 2010
}


{ Vexer takes advantage of the fact that in turborisk, card turn in value is incremented per player,
whereas traditionally (in the US version at least) the CTIV increments for all players every time a trade is
turned in. This makes it even more advantageous to make sure you get your card each turn and to kill
players for their cards. Both things Vexer does well. }

{ Ubuffer Usage:

  Placement:
  51 - Used to determine if it's the first placement of the game
  52 - Last Territory Placed
  53 - Keeps track of the card turn in value
  54 - set to 1 if Cards have been turned in this turn
  55 - Stores the change in CTIV
  56 - Stores variable extra2/extra
  57 - set to 1 if it's the first placement of the turn
  58 - stores how much is enough
  59 - tells the placement routine not to check for kill player placement until the next turn
  151 - stores how many times to place to buffer 52
  89 - tells the attack proc to not try and kill the weakest player

  Attack:
  60 - signal to occupation proc, attack determined by Attack Strong Player Code
  61 - successive turns without conquest counter
  62 - keeps track of how many total turns I've gone without conquest
  63 - Kill Player Mode
  64 - attack all players
  65 - reduce build up mode
  66 - use TPathToFront fortification code
  67 - used to tell the occupation routine to set Armies:= 0
  68 - reuse the last ToTerritory
  69 - reuse the last FromTerritory
  85 - stores how many times to repeat that last attack
  86 - stores the previous owner of the ToTerritory
  87 - stores the fact that it's not possible to kill the stored player until you can place more armies
  88 - same as above
  90 - take continent mode
  91 - keeps track of the last territory I conquered when taking a continent
  92 - tells the occupation routine the T I've attacked in take continent mode
  93 - tells the fortification routine to pause the game with a UMessage
  94 - don't check if you can kill the weakest player again until next turn
  95 - KillPlayerAttack2 - stores the last DT that was found with the 2nd set of code
  96 - stores DT for use with KillPlayerOcc
  97 - stores DT when determined by the second set of code, for use with KillPlayerOcc
  98 - reuse the last Toterritory until TArmies(Toterritory) < 3
  99 - reuse the last FromTerritory
 100 - these 2 same as above 2 but for Attack strong player code

  Occupation:
  70 - set to 1 in occupation routine, 0 in attack - determines if the occupation routine wasn't called because there weren't any armies left to occupy with
  71 - Keeps track of the last territory I conquered
  72 - Keeps track of how many times I've attacked the same territory
  73 - Keeps track of where my next FromTerritory should be
  74 - Keeps track of where my next ToTerritory should be
  75 - Tells the attack procedure to take another float attack
  76 - turns on a umessage when the occ actually happens
  77 - used with KillPlayerOcc stores BestFT
  78 - tells killplayerOcc not to repeat the "dead end" code
  79 - stores FTNeedsMore for killplayerOcc - used with buffer 77
  80 - stores BestTT - used with 77
  82 - tells the killplayerOcc to set armies:= TTNeeds

  Fortification:
  81 - Stores a turn count that doesn't include initial placement
}

{ Feel free to use any of my functions or procedures for your own TRPs.  After
reading the function's name, it may sound like it is good for general use but it's
actually customized for Vexer.  If you need help making a function work for your TRP,
send me an email describing what you want the function to do and I can modify it for you. }

Var
  QTArmies, QTOwner: Array of Integer;
  NeedToCheck: array [1..42] of boolean;
  aQNode: array [1..42] of record
    bClosed: boolean;
    bOpen: boolean;
  end;
  TTNeeds: array [1..42] of integer;
  AccountedFor: array [1..42] of boolean;
  KillBoth, Weaken1: boolean;


{_________________________ UMessage/Ulog/UBuffer ______________________________}

function m(s: string): boolean;  // shortens UMessage to m
begin
  result:= false;
  //ULog('m: ' + s);  // duplicates all messages to the log
  {
  case UDialog(s,'Continue;SnapShot;Stop;Both') of
    1: ;
    2: UTakeSnapShot(s + ' Turn: ' + inttostr(trunc(UBufferGet(81))));
    3: begin
      UAbortGame;
      exit;
    end;
    4: begin
      UTakeSnapShot(s + ' Turn: ' + inttostr(trunc(UBufferGet(81))));
      UAbortGame;
      exit;
    end;
  end;
  }
end;

function m2(s: string): boolean;  // used when working on new code and I don't want all the above m dialogs popping up
begin

  result:= False;
  {
  ULog('m2: ' + s);  // duplicates all messages to the log

  case UDialog(s,'Continue;SnapShot;Stop;Both') of
    1: ;
    2: UTakeSnapShot(s + 'Turn: ' + inttostr(trunc(UBufferGet(81))));
    3: begin
      UAbortGame;
      Result:= True;
      exit;
    end;
    4: begin
      UTakeSnapShot(s + ' Turn: ' + inttostr(trunc(UBufferGet(81))));
      UAbortGame;
      Result:= True;
      exit;
    end;
  end;
  }

end;

procedure l(s: string);  // shortens Ulog to l
begin
  //ULog(s);  // comment off this line to disable all Ulogs
  //UMessage(s);
  //  if (QTOwner[27] = PMe) and (QTOwner[30] <> PMe) then UMessage(s); // enable this line to display logs as messages ( Useful in TRComp's simulation mode)
  //if PTerritoriesCount(Pme) = 41 then Ulog('Armies: ' + inttostr(PArmiesCount(Pme)));
end;

function i(x: integer): string;  // shortens inttostr to i
begin result:= inttostr(x); end;

function f(x: double): string;  // shortens floattostr to f
begin result:= floattostr(x); end;

// example m('ToTerritory: ' + i(ToTerritory) + ' FromTerritory: ' + i(FromTerritory));

function bg(x: integer): integer;
begin result:= trunc(UBufferGet(x)); end;
                                              // use these for integer storage
procedure bs(x, y: integer);
begin UBufferSet(x, y); end;
{______________________________________________________________________________}

function TIV: integer; begin if SCardsBasedOnCombo then result:= 6 else result:= PCardTurnInValue(PMe); end;
function PTC: integer; begin result:= PTerritoriesCount(PMe); end;

Procedure InitializeQMap;
Var X: integer;
Begin
  SetArrayLength(QTArmies, 43);
  SetArrayLength(QTOwner, 43);
  For X:= 1 to 42 do begin
    QTArmies[X]:= TArmies(X);
    QTOwner[X]:= TOwner(X);
  end;
end;

Procedure InitializeQMapKillBoth(P: integer);
Var X: integer;
Begin
  SetArrayLength(QTArmies, 43);
  SetArrayLength(QTOwner, 43);
  For X:= 1 to 42 do begin
    QTArmies[X]:= TArmies(X);
    If TOwner(X) = PMe then QTOwner[X]:= PMe else QTOwner[X]:= P;
  end;
end;

Function GameHasNoHumans: boolean;
var
  P: integer;
begin
  result:= true;
  for P:= 1 to 10 do begin
    if PHuman(P) and PAlive(P) then result:= false;
  end;
end;

function GameHasOneHuman(var P: integer): boolean;
Var Human, C: integer;
Begin
  C:= 0;
  For P:= 1 to 10 do begin
    If PHuman(P) and PAlive(P)then begin
    //if (PProgram(P) = 'vexer-no killwp.trp') and PAlive(P) then begin
      C:= C + 1;
      Human:= P;
    end;
  end;
  if C = 1 then begin
    result:= true;
    P:= Human;
  end else begin
    result:= false;
    P:= 0;
  end;
end;

Procedure ConquestForce(Var CForce: integer);
Var P: integer;
Begin
  CForce:= (TIV div 3) + 2;
  // if I haven't earned a card in the last 3 turns then
  if (bg(61) > 2) and (not SCardsBasedOnCombo) then begin
    if GameHasOneHuman(P) and (  PArmiesCount(P) > ( trunc(0.9 * double(PArmiesCount(PMe))) )  ) then
      CForce:= trunc(double(CForce) * 1.4 * double(bg(61) - 1)) + 2
    else
      CForce:= trunc(double(CForce) * 1.8 * double(bg(61) - 1)) + 3;
  end;
end;

Function QTWeakestPath(ST, DT, Mode: integer; var TT, PL, EA: integer): boolean;
Var
  iPL, ChildArmies, T, B, iNode, iChild, iCostFromStart: integer;
  bFound: boolean;

  aNode: array [1..42] of record
    bClosed: boolean;          // node is in the CLOSED list
    bOpen: boolean;            // node is in the Open list
    iParent: integer;          // previous node in the optimal path
    iCostFromStart: integer;   // cost to arrive to this node
    iPL: integer;              // Path length from this node to the start T
  end;

begin
  // mode 0 - use actual TArmies and TOwners
  // mode 1 - use the test values QTArmies and QTOwner

  if mode = 0 then begin          // this should already be done if mode is 1 using the InitializeQMap procedure
    SetArrayLength(QTOwner, 43);   // the lengths have to be set even if they aren't used
    SetArrayLength(QTArmies, 43);
  end;

  Result:= False;
  TT:= 0;
  PL:= 0;
  EA:= 0;

  if (ST = 0) or (DT = 0) or (ST = DT) then exit;

  if (mode = 0) and (TIsBordering(ST, DT) and (TOwner(ST) = PMe) and (TOwner(DT)= PMe)) then exit;
  if (mode = 1) and (TIsBordering(ST, DT) and (QTOwner[ST] = PMe) and (QTOwner[DT]= PMe)) then exit;


  for T:=1 to 42 do begin
    with aNode[T] do begin
      bClosed := false;
      bOpen:= false;
    end;
  end;

  aNode[ST].iParent := 0;
  aNode[ST].iCostFromStart := 0;
  aNode[ST].iPL:= 0;
  aNode[ST].bopen := True;

  Repeat
    T:= 0;
    iNode:= 0;
    repeat
      T:= T + 1;
      if aNode[T].bopen and not aNode[t].bClosed then begin
        iNode:= T;
      end;
    until (iNode > 0) or (T = 42);

    if iNode = DT then bFound:= True;

    if iNode <> 0 then begin
      if not (iNode = DT) then begin
        // examine connected nodes
        for B:= 1 to TBordersCount(iNode) do begin
          iChild:= TBorder(iNode, B);
          // skip Ts that are mine
          if (mode = 0) and (TOwner(iChild) = PMe) then continue;
          if (mode = 1) and (QTOwner[iChild] = PMe) then continue;

          if mode = 0 then ChildArmies:= TArmies(iChild) else ChildArmies:= QTArmies[iChild];
          iCostFromStart:= aNode[iNode].iCostFromStart + ChildArmies + 1;  // add 1 to incorporate the cost of the path length into the total cost
          iPL:= aNode[iNode].iPL + 1;
          // assign cost to child if end node has not been reached already
          // or if reached with higher cost
          if ((not aNode[iChild].bOpen) and (not aNode[iChild].bClosed))
          or (iCostFromStart < aNode[iChild].iCostFromStart) or ( (iCostFromStart = aNode[iChild].iCostFromStart) and (iPL < aNode[iChild].iPL) ) then begin
            aNode[iChild].iParent := iNode;
            aNode[iChild].iCostFromStart := iCostFromStart;
            aNode[iChild].iPl:= iPL;
            if aNode[iChild].bClosed then aNode[iChild].bClosed:= false; // if closed then remove child from CLOSED list
            if not aNode[iChild].bOpen then aNode[iChild].bOpen:= true;  // add to open list
          end;
        end;
      end;
      aNode[iNode].bClosed := true; // node has been examined, add to CLOSED list
    end;
  until (iNode = 0);  // loop until there are no more open nodes

  if bFound then begin
    Result:= True;
    EA:= aNode[DT].iCostFromStart - aNode[DT].iPL;
    PL:= aNode[DT].iPL;
//    l('DT ' + i(DT));
    while (aNode[DT].iParent > 0) and (aNode[DT].iParent <> ST) do begin
      DT := aNode[DT].iParent;
//      l('DT ' + i(DT)); // displays the territories in the path
    end;
    TT:= DT;
  end;
end;

Function PlaceToKillPlayer2(WP, ST, PathCostTotal: integer; var Cost, MaxArmy: integer): boolean;
Var
  TTUsedChild, TTUsedMaxArmy, T, B, iNode, iChild: integer;

  aNode: array [1..42] of record
    bClosed: boolean;
    bOpen: boolean;
    Cost: integer;
  end;

begin

  Result:= False;
  Cost:= 0;
  MaxArmy:= 0;

  for T:=1 to 42 do begin
    with aNode[T] do begin
      bClosed := false;
      bOpen:= false;
      Cost:= 0;
    end;
  end;

  aNode[ST].bopen := True;

  Repeat
    T:= 0;
    iNode:= 0;
    repeat
      T:= T + 1;
      if aNode[T].bopen and not aNode[t].bClosed then begin
        iNode:= T;
      end;
    until (iNode > 0) or (T = 42);

    if iNode <> 0 then begin
      for B:= 1 to TBordersCount(iNode) do begin
        iChild:= TBorder(iNode, B);
        if iChild = ST then continue;
        if (TOwner(iChild) <> PMe) and (TOwner(iChild) <> PMe) then Cost:= aNode[iNode].Cost + TArmies(iChild) + 1 else Cost:= aNode[iNode].Cost;
        if TOwner(iChild) = PMe then begin
          //Cost:= aNode[iNode].Cost;
         // if m2('sub function inode ' + i(inode) + ' anode[inode].cost ' + i(anode[inode].cost) + ' ichild ' + i(ichild) + ' anode[ichild].cost ' + i(anode[ichild].cost)) then exit;
          if aNode[iChild].Cost > 0 then begin
            if aNode[iNode].Cost < aNode[iChild].Cost then aNode[iChild].Cost:= aNode[iNode].Cost;
          end else aNode[iChild].Cost:= aNode[iNode].Cost;
          if ( aNode[iChild].Cost <  (PArmiesCount(PME) +  PNewArmies(PMe) - PathCostTotal - PTerritoriesCount(PMe)) - (PArmiesCount(WP) + PTerritoriesCount(WP)) ) then begin
            if (MaxArmy = 0) then MaxArmy:= iChild else begin
              if (iChild <> MaxArmy) then begin
                if TTNeeds[iChild] > 0 then begin
                  if TTNeeds[iChild] > TArmies(iChild) - 1 then TTUsedChild:= TArmies(iChild) - 1 else TTUsedChild:= TTNeeds[iChild];
                end else TTUsedChild:= 0;
                if TTNeeds[MaxArmy] > 0 then begin
                  if TTNeeds[MaxArmy] > TArmies(MaxArmy) - 1 then TTUsedMaxArmy:= TArmies(MaxArmy) - 1 else TTUsedMaxArmy:= TTNeeds[MaxArmy];
                end else TTUsedMaxArmy:= 0;

             //   l('sub function st ' + i(st) + ' ttusedMaxarmy ' + i(ttusedmaxarmy) + ' ttusedchild ' + i(ttusedchild) + ' childcost ' + i(aNode[iChild].Cost) +
             //   ' maxarmyCost ' + i(aNode[MaxArmy].Cost) + ' ichild ' + i(ichild) + ' maxarmy ' + i(maxarmy));
                if (TArmies(iChild) - TTUsedChild - aNode[iChild].Cost > TArmies(MaxArmy) - TTUsedMaxArmy - aNode[MaxArmy].Cost) then begin
                  MaxArmy:= iChild;
            //      l('MaxArmy assign: ' + i(maxarmy));
                end;
              end;
            end;
          end;
        end;

        if ((not aNode[iChild].bOpen) and (not aNode[iChild].bClosed))
        or (Cost < aNode[iChild].Cost) then begin
          if TOwner(iChild) <> PMe then begin
            aNode[iChild].Cost:= Cost;
            if ( aNode[iChild].Cost <  (PArmiesCount(PME) +  PNewArmies(PMe) - PathCostTotal - PTerritoriesCount(PMe)) - (PArmiesCount(WP) + PTerritoriesCount(WP)) )
              and (not AccountedFor[ichild]) then begin
              aNode[iChild].bClosed:= false;
              aNode[iChild].bOpen:= true;
            end;
          end;
        end;
        //m2('ichild ' + i(ichild) + ' cost ' + i(anode[ichild].cost));
      end;
      aNode[iNode].bClosed := true;
    end;
   // if m2('end of repeat 0, inode: ' + i(inode)) then exit;
  until (iNode = 0);

  if MaxArmy > 0 then begin
    result:= true;
    Cost:= aNode[MaxArmy].Cost;
  end else Cost:= 0;

end;

Function WeakestPathToWP(P, ST: integer; var TT, DT, Cost: integer): boolean;
Var
  Ts, TempTT, MinCost, MinCostT, T, B, iNode, iChild, iCostFromStart: integer;

  aNode: array [1..42] of record
    bClosed: boolean;          // node is in the CLOSED list
    bOpen: boolean;            // node is in the Open list
    iParent: integer;          // previous node in the optimal path
    iCostFromStart: integer;   // cost to arrive to this node
  end;
  Checked: array [1..42] of boolean;
begin

  Result:= False;
  TT:= 0;
  Cost:= 0;
  if (ST = 0) then exit;
  //l('ST: ' + I(ST));
  MinCost:= 999999999;
  MinCostT:= 0;
  aNode[ST].iParent := 0;
  aNode[ST].iCostFromStart := 0;
  For T:= 1 to 42 do Checked[T]:= False;

  Repeat
    DT:= 0;
    T:= 0;
    Repeat
      T:= T + 1;
      If NeedToCheck[T] and (Not Checked[T]) and (not (T=ST)) then begin
        DT:= T;
        Checked[DT]:= True;
      end;
    Until (DT > 0) or (T = 42);
    //l('Repeat DT: ' + i(DT));

    if DT > 0 then begin

      for T:=1 to 42 do begin
        with aNode[T] do begin
          bClosed := false;
          bOpen:= false;
        end;
      end;

      aNode[ST].bopen := True;
      Repeat
        T:= 0;
        iNode:= 0;
        repeat
          T:= T + 1;
          if aNode[T].bOpen and not aNode[T].bClosed then begin
            iNode:= T;
          end;
        until (iNode > 0) or (T = 42);

        if iNode <> 0 then begin
          if not (iNode = DT) then begin
            // examine connected nodes
            for B:= 1 to TBordersCount(iNode) do begin
              iChild:= TBorder(iNode, B);
              // skip Ts that are mine
              if (QTOwner[iChild] = PMe) then continue;

              iCostFromStart:= aNode[iNode].iCostFromStart + QTArmies[iChild] + 1;  // add 1 to incorporate the cost of the path length into the total cost
              // assign cost to child if end node has not been reached already
              // or if reached with higher cost
              if ((not aNode[iChild].bOpen) and (not aNode[iChild].bClosed))
              or (iCostFromStart < aNode[iChild].iCostFromStart) then begin
                aNode[iChild].iParent := iNode;
                aNode[iChild].iCostFromStart := iCostFromStart;                                             // this line prevents the function from finding
                                                  // don't include the EA from the MinCostT                // dont want to include Ts that border dt
                if (iChild = DT) and (aNode[iNode].iCostFromStart < MinCost) {and (not (iNode = ST))} then begin
                  MinCost:= aNode[iNode].iCostFromStart;
                  MinCostT:= iChild;
                //  Checked[iChild]:= True;
                //  l('1 MinCostT: ' + i(MinCostT) + ' MinCost ' + i(MinCost));
                end;
                if aNode[iChild].bClosed then aNode[iChild].bClosed:= false; // if closed then remove child from CLOSED list
                if not aNode[iChild].bOpen then aNode[iChild].bOpen:= true;  // add to open list
              end;
            end;
          end;
          aNode[iNode].bClosed := true; // node has been examined, add to CLOSED list
        end;
      until (iNode = 0);  // loop until there are no more open nodes
    end;
  until DT = 0;

  if MinCostT > 0 then begin
    //m2('here');
    Result:= True;
    Cost:= aNode[aNode[MinCostT].iParent].iCostFromStart;
    TempTT:= MinCostT;
    //l('weakestpathToWP MinCostT: ' + i(MinCostT) + ' Cost ' + i(Cost));
    Ts:= 0;
    while (aNode[TempTT].iParent > 0) and (aNode[TempTT].iParent <> ST) do begin
      TempTT := aNode[TempTT].iParent;
      Ts:= Ts + 1;
     // l('TempTT ' + i(TempTT)); // displays the territories in the path
    end;
    TT:= TempTT;
    Cost:= Cost + Ts div 3;
    DT:= MinCostT;
  end;// else m('MincostT not found');
end;

Function QDistance(P, ST, DT, FT: integer; Var PL: integer): boolean;
Var
  B2, BT2, C, BT, BT1, iPL, T, B, B1, iNode, iChild: integer;
  bFound: boolean;

  aNode: array [1..42] of record
    bClosed: boolean;          // node is in the CLOSED list
    bOpen: boolean;            // node is in the Open list
    PL: integer;   // cost to arrive to this node
  end;

begin
  //l('qdistance called');
  Result:= False;
  PL:= 0;

  if (ST = 0) or (DT = 0) or (ST = DT) then exit;

  if TIsBordering(ST, DT) and (QTOwner[ST] = PMe) and (QTOwner[DT] = PMe) then exit;

  for T:=1 to 42 do begin
    with aNode[T] do begin
      bClosed := false;
      bOpen:= false;
    end;
  end;

  aNode[ST].PL := 0;
  aNode[ST].bopen := True;

  bFound := false;
  Repeat
    T:= 0;
    iNode:= 0;
    repeat
      T:= T + 1;
      if aNode[T].bopen and not aNode[t].bClosed then begin
        iNode:= T;
      end;
    until (iNode > 0) or (T = 42);

    if iNode = DT then bFound:= True;

    if iNode <> 0 then begin
      if not (iNode = DT) then begin
        // examine connected nodes
        for B:= 1 to TBordersCount(iNode) do begin
          iChild:= TBorder(iNode, B);
          // skip Ts that are not owned by player P
          if (QTOwner[iChild] <> P) and (not ( (iChild = DT) or (iChild = FT) )) then continue;

          // determine if I should go through the FT to determine distance
          C:= 0;
          if iChild = FT then begin
            B1:= 0;
            Repeat
              B1:= B1 + 1
              //if C = 0 then begin
              BT:= TBorder(FT, B1);
              if (not (BT = iNode)) and (QTOwner[BT] = P) then begin
                B2:= 0;
                Repeat
                  B2:= B2 + 1;
                  BT2:= TBorder(BT, B2);
                  if BT2 = iNode then C:= C + 1;
                 // if m2('inode ' + i(inode) +  ' c ' + i(c)) then exit;
                Until (C > 0) or (B2 = TBordersCount(BT));
              end;
            Until (C > 0) or (B1 = TBordersCount(FT));
          end;
          if C > 0 then continue;

          iPL:= aNode[iNode].PL + 1;  // add 1 to incorporate the cost of the path length into the total cost

          // assign cost to child if end node has not been reached already
          // or if reached with higher cost
          if ((not aNode[iChild].bOpen) and (not aNode[iChild].bClosed))
          or (iPL < aNode[iChild].PL) then begin
            aNode[iChild].PL := iPL;
            if aNode[iChild].bClosed then aNode[iChild].bClosed:= false; // if closed then remove child from CLOSED list
            if not aNode[iChild].bOpen then aNode[iChild].bOpen:= true;  // add to open list
          end;
        end;
      end;
      aNode[iNode].bClosed := true; // node has been examined, add to CLOSED list
    end;
  until (iNode = 0);  // loop until there are no more open nodes

  if bFound then begin
    Result:= True;
    PL:= aNode[DT].PL;
  end else result:= False;
    //l('QDistance ' + pname(p) + ' st ' + i(st) + ' dt ' + i(dt) + ' pl ' + i(pl));

end;

Function QShortestPath(P, ST, DT, NewFT: integer; Var PL: integer; var Path: array of integer): boolean;
Var
  PL2, PL1, n, iPL, T, B, iNode, iChild: integer;
  bFound: boolean;

  aNode: array [1..42] of record
    bClosed: boolean;
    bOpen: boolean;
    PL: integer;
    iParent: integer;
  end;

begin
  //m2('begin qshortest path');
  Result:= False;
  PL:= 0;

  if (ST = 0) or (DT = 0) or (ST = DT) then exit;

  if TIsBordering(ST, DT) and (QTOwner[ST] = PMe) and (QTOwner[DT]= PMe) then exit;

  for T:=1 to 42 do begin
    with aNode[T] do begin
      bClosed := false;
      bOpen:= false;
    end;
  end;

  aNode[ST].PL := 0;
  aNode[ST].iParent := 0;
  aNode[ST].bopen := True;

  bFound := false;
  Repeat
    T:= 0;
    iNode:= 0;
    repeat
      T:= T + 1;
      if aNode[T].bopen and not aNode[t].bClosed then begin
        iNode:= T;
      end;
    until (iNode > 0) or (T = 42);

    if iNode = DT then bFound:= True;

    if iNode <> 0 then begin
      if not (iNode = DT) then begin
        // examine connected nodes
        for B:= 1 to TBordersCount(iNode) do begin
          iChild:= TBorder(iNode, B);
          // skip Ts that are not owned by player P
          if (QTOwner[iChild] <> P) then continue;

          iPL:= aNode[iNode].PL + 1;  // add 1 to incorporate the cost of the path length into the total cost

          // assign cost to child if end node has not been reached already
          // or if reached with higher cost
          if ((not aNode[iChild].bOpen) and (not aNode[iChild].bClosed))
           or (iPL < aNode[iChild].PL) then begin
            aNode[iChild].iParent := iNode;
            aNode[iChild].PL := iPL;
            if aNode[iChild].bClosed then aNode[iChild].bClosed:= false; // if closed then remove child from CLOSED list
            if not aNode[iChild].bOpen then aNode[iChild].bOpen:= true;  // add to open list
          end;
          if (iPL = aNode[iChild].PL) and (aNode[iChild].iParent <> iNode) then begin

            QDistance(P, iNode, NewFT, 0, PL2);
            QDistance(P, aNode[iChild].iParent, NewFT, 0, PL1);
            if PL2 > PL1 then begin
              aNode[iChild].iParent := iNode;
              if aNode[iChild].bClosed then aNode[iChild].bClosed:= false; // if closed then remove child from CLOSED list
              if not aNode[iChild].bOpen then aNode[iChild].bOpen:= true;  // add to open list
            end;
          end;
        end;
      end;
      aNode[iNode].bClosed := true; // node has been examined, add to CLOSED list
    end;
  until (iNode = 0);  // loop until there are no more open nodes

  if bFound then begin
    Result:= True;
    PL:= aNode[DT].PL;
    SetArrayLength(Path, PL + 1);
    Path[PL]:= DT;
    l('path, n: ' + i(PL) + ' T: ' + i(Path[PL]));
    for n:= PL - 1 downto 1 do begin
      Path[n]:= aNode[path[n + 1]].iParent;
      l('path, n: ' + i(n) + ' T: ' + i(Path[n]));
    end;
//    l('QDistance ' + pname(p) + ' st ' + i(st) + ' dt ' + i(dt) + ' pl ' + i(pl));
  end else result:= False;
end;


Procedure AllTsConnected(P, TT: integer; var ATC: boolean);
Var
  PTC1, Total, X, BT, C, B, T: integer;
  TOwnerIsPlayerP, Checked: array of boolean;
begin
  ATC:= False;
  if not (P = 0) then begin
    SetArrayLength(Checked, 43);
    For x:= 1 to 42 do Checked[x]:= False;
    SetArrayLength(TOwnerIsPlayerP, 43);
    For x:= 1 to 42 do TOwnerIsPlayerP[x]:= False;
    PTC1:= PTerritoriesCount(P);

    if TT > 0 then PTC1:= PTerritoriesCount(P) - 1;
    ATC:= True;
    T:= 0;
    Repeat
      T:= T + 1;
      If (TOwner(T) = P) and (not (T = TT)) then break;
    Until (T > 42);
    if T > 42 then T:= 0;
    TOwnerIsPlayerP[T]:= True;
    Total:= 0;
    Repeat
      if TOwnerIsPlayerP[T] and (not Checked[T]) then begin
        C:= 0;
        For B:= 1 to TBordersCount(T) do begin
          BT:= TBorder(T, B);
          if (  (TOwner(BT) = P) or ( (TOwner(BT) = PMe) and (TArmies(BT) > 3) )  )
           and (not TOwnerIsPlayerP[BT]) and (not (BT = TT)) then begin
            if (TOwner(BT) = Pme) then PTC1:= PTC1 + 1;
            C:= C + 1;
            TOwnerIsPlayerP[BT]:= True;
          end;
        end;
        Checked[T]:= True;
        Total:= Total + 1;
        if C > 0 then T:= 0;
      end;
      T:= T + 1;
    Until (T > 42);
    if Total <> PTC1 then ATC:= False;
  end;
end;

Procedure KillPlayerAttack2(P: integer; var FT, TT: integer);
Var
  MaxDistance, MinDistance1, MinDistance2, Distance, Distance1, DT,
  MinDistance, MinBorders, MaxFronts, PL, EA, C, BT, T, B, iNode, iChild,
  MaxArmy, NewFT, C1, C2, FrontsCountT, FrontsCountDT, MinArmies, T1, Borders,
  MinArmy, MinArmyT, oFT, oDT, Counter, tempFT, n, ET, BT1, B1: integer;

  go: boolean;
  Points, MinPoints, MaxPoints: Double;

  DistanceA: array [1..42] of integer;
  Path: Array of integer;
  IsFront: array [1..42] of boolean;
  // aQNode is a global variable
begin
  TT:= 0;
  l('kill player attack FT: ' + i(ft));

  for T:=1 to 42 do begin
    with aQNode[T] do begin
      bClosed := false;
      bOpen:= false;
    end;
    IsFront[T]:= false;
  end;
  //if ft = 27 then m('pause ft = 35 begin');
  // Find all of Player P's Ts that are connected to FT and add them to the open list
  aQNode[FT].bOpen := True;

  Repeat
    T:= 0;
    iNode:= 0;
    repeat
      T:= T + 1;
      if aQNode[T].bOpen and not aQNode[T].bClosed then begin
        iNode:= T;
      end;
    until (iNode > 0) or (T = 42);

    if iNode > 0 then begin
      for B:= 1 to TBordersCount(iNode) do begin
        iChild:= TBorder(iNode, B);
        // skip Ts that aren't Player P's
        if (QTOwner[iChild] <> P) then continue;
        aQNode[iChild].bOpen:= true;
      end;
      aQNode[iNode].bClosed := true; // node has been examined, add to CLOSED list
    end;
  until (iNode = 0);  // loop until there are no more open nodes

  aQNode[FT].bOpen:= False; // remove the FT from the list of possibilities

  // Find the T that connects with an FT that is Front and has relatively few armies
  MaxFronts:= 0;
  DT:= 0;
  bs(96, 0);
  bs(97, 0);
  MinPoints:=999999999;
  For T:= 1 to 42 do begin
    if aQNode[T].bopen then begin
      MinArmies:= 999999999;
      For B:= 1 to TBordersCount(T) do begin
        BT:= TBorder(T, B);
        if (QTOwner[BT] <> P) and (QTOwner[BT] <> PMe) then begin
          if QTArmies[BT] < MinArmies then MinArmies:= QTArmies[BT];
        end;
        if (QTOwner[BT] = PMe) then IsFront[T]:= True;
      end;
      if (MinArmies <> 999999999) or (SAlivePlayersCount = 2) or KillBoth then begin
        IsFront[T]:= False;
        if QDistance(P, FT, T, 0, PL) then begin
          Points:= (1/double(PL)) - (1/double(MinArmies));
          if Points < MinPoints then begin
            MinPoints:= Points;
            DT:= T;
          end;
          if Points = MinPoints then begin
            FrontsCountDT:= 0;
            FrontsCountT:= 0;
            For B:= 1 to TBordersCount(DT) do begin
              BT:= TBorder(DT, B);
              if (QTOwner[BT] <> P) and (QTOwner[BT] <> PMe) then FrontsCountDT:= FrontsCountDT + 1;
            end;
            For B:= 1 to TBordersCount(T) do begin
              BT:= TBorder(T, B);
              if (QTOwner[BT] <> P) and (QTOwner[BT] <> PMe) then FrontsCountT:= FrontsCountT + 1;
            end;
            If FrontsCountT > FrontsCountDT then DT:= T;
          end;
        end;
      end;
    end;
  end;
  bs(96, DT);

  l('1 DT ' + i(DT));

  if DT = 0 then begin
    MinDistance:= 999999999;
    MaxPoints:=0;
    For T:= 1 to 42 do begin
      If IsFront[T] then begin
        For T1:= 1 to 42 do begin
          if (QTOwner[T1] <> PMe) and (QTOwner[T1] <> P) then begin
            // Find EnemyT's fronts
            MinArmies:= 999999999;
            For B:= 1 to TBordersCount(T1) do begin
              BT:= TBorder(T1, B);
            //  l('bt ' + i(bt));
              if QTOwner[BT] <> QTOwner[T1] then begin
                if QTArmies[BT] < MinArmies then begin
                  MinArmies:= QTArmies[BT];
                end;
              end;
            end;
            if MinArmies <> 999999999 then begin
              TDistance(T, T1);
              Points:= (1/double(TDistance(T, T1))) + (1/double(MinArmies));
              if Points > MaxPoints then begin
                MaxPoints:= Points;
                DT:= T;
              end;
              if Points = MaxPoints then begin   // should it be dt, t1
                if TDistance(T, T1) < TDistance(T, DT) then DT:= T;
              end;
            end;
          end;
        end;
      end;
    end;
    bs(97, DT);
    l('2 DT ' + i(DT));
  end;

  if (DT > 0) then begin
    NewFT:= 0;
    MaxArmy:= 0;
    MinArmy:= 0;
    MinArmyT:= 0;
    For T:= 1 to 42 do begin
      if aQNode[T].bopen then begin
        For B:= 1 to TBordersCount(T) do begin
          BT:= TBorder(T, B);
          if (QTOwner[BT] = PMe) and (not (BT = FT)) and (QTArmies[BT] > 3) then begin
            C:= 0;
            For B1:= 1 to TBordersCount(BT) do begin
              BT1:= TBorder(BT, B1);
              if (QTOwner[BT1] = P) and (not aQNode[BT1].bOpen) then C:= C + 1;
            end;
            if C = 0 then begin
              if (QTArmies[BT] < MinArmy) or (MinArmy = 0) then begin
                MinArmy:= QTArmies[BT];
                MinArmyT:= BT;
              end;
              if QTArmies[BT] > MaxArmy then begin
                MaxArmy:= QTArmies[BT];
                NewFT:= BT;
              end;
            end;
          end;
        end;
      end;
    end;

    if (NewFT <> MinArmyT) then begin
      For B:= 1 to TBordersCount(MinArmyT) do begin
        BT:= TBorder(MinArmyT, B);
        if (QTOwner[BT] = P) and (QTArmies[BT] > 2) then begin
          FT:= MinArmyT;
          TT:= BT;
          bs(98, TT);
          bs(99, FT);
          if m2('attack with MinArmyT: ' + i(FT) + ' TT: ' + i(TT)) then exit;
          exit;
        end;
      end;
    end;
    if NewFT > 0 then m2('newFT: ' + i(NewFT));
  end;

  if NewFT > 0 then if not QShortestPath(P, FT, DT, NewFT, PL, Path) then NewFT:= 0;

  if DT = 0 then begin
    m('DT = 0');
    MinBorders:= 7;
    For B:= 1 to TBordersCount(FT) do begin
      BT:= TBorder(FT, B);
      if (QTOwner[BT] = P) then begin
        Borders:= 0;
        For B1:= 1 to TBordersCount(BT) do begin
          BT1:= TBorder(BT, B1);
          if QTOwner[BT1] = P then Borders:= Borders + 1;
        end;
        if Borders < MinBorders then begin
          MinBorders:= TBordersCount(BT);
          TT:= BT;
          l('******************** dt = 0 minborders code, TT:= ' + i(TT) + ' **************************');
        end;
      end;
    end;
  end else begin
    Counter:= 1;
    oFT:= FT;
//    oDT:= DT;
    If NewFT = 0 then Counter:= 2 else begin
      FT:= NewFT;
    end;
    repeat
      if Counter = 2 then begin
        FT:= oFT;
//        DT:= oDT;
        NewFT:= 0;
      end;
      if NewFT = 0 then begin
        // attack the T that has no connecting T's first
        For B:= 1 to TBordersCount(FT) do begin
          BT:= TBorder(FT, B);
          if (QTOwner[BT] = P) and (not (BT = DT)) then begin
            if (QTArmies[FT] > QTArmies[BT]) and (not ( (QTArmies[FT] < 4) and (QTArmies[BT] > 1) )) then begin
              C:= 0;
              For B1:= 1 to TBordersCount(BT) do begin
                BT1:= TBorder(BT, B1);
                if QTOwner[BT1] = P then C:= C + 1;
              end;
              if (C = 0) then begin
                TT:= BT;
                l('no borders tt code, TT: ' + i(TT));
              end;
            end;
          end;
        end;
      end;

      // Find FTs border that is farthest from DT
      if TT = 0 then begin
//        m2('FT ' + i(FT) + ', DT ' + i(DT));
        MaxDistance:= -1;
        //if SAlivePlayerCount < 5 then m('pause 1');
        For B:= 1 to TBordersCount(FT) do begin
//              l('b ' + i(b));
          BT:= TBorder(FT, B);
  //              l('bt ' + i(bt));
          if QTOwner[BT] = P then begin
            if ( (QTArmies[FT] > QTArmies[BT]) or (NewFT > 0) ) and (not ( (QTArmies[FT] < 4) and (QTArmies[BT] > 1) )) then begin
              go:= False;
              {if DistanceA[BT] > 0 then go:= True else }if QDistance(P, BT, DT, FT, DistanceA[BT]) then go:= true;
              if go then begin
    //            l('BT: ' + i(BT) + ' DistanceA: ' + i(DistanceA[BT]));
                if DistanceA[BT] > MaxDistance then begin
                  MaxDistance:= DistanceA[BT];
                  TT:= BT;
      //            l('aTT ' + i(TT));
                end else begin
                  if DistanceA[BT] = MaxDistance then begin
                    MinDistance1:= 100;
                    For B1:= 1 to TBordersCount(TT) do begin
        //                 l('1 b1 ' + i(b1));
                      BT1:= TBorder(TT, B1);
          //                  l('1 bt1 ' + i(bt1));
                      if QTOwner[BT1] = P then begin
                        go:= False;
                        {if DistanceA[BT1] > 0 then go:= True else }if QDistance(P, BT1, DT, FT, DistanceA[BT1]) then go:= true;
                        if go then begin
                          if DistanceA[BT1] < MinDistance1 then begin
                            MinDistance1:= DistanceA[BT1];
                          end;
                        end;
                      end;
                    end;
                    MinDistance2:= 100;
                    For B1:= 1 to TBordersCount(BT) do begin
            //             l('2 b1 ' + i(b1));
                      BT1:= TBorder(BT, B1);
              //             l('2 bt1 ' + i(bt1));
                      if QTOwner[BT1] = P then begin
                        go:= False;
                        {if DistanceA[BT1] > 0 then go:= True else} if QDistance(P, BT1, DT, FT, DistanceA[BT1]) then go:= true;
                        if go then begin
                          if DistanceA[BT1] < MinDistance2 then begin
                            MinDistance2:= DistanceA[BT1];
                          end;
                        end;
                      end;
                    end;
                    l('MD1 ' + i(MinDistance1) + ' MD2 ' + i(MinDistance2));
                    if MinDistance1 < MinDistance2 then TT:= BT;
                    if (MinDistance1 = MinDistance2) then begin
                      C1:= 0;
                      C2:= 0;
                      For B1:= 1 to TBordersCount(TT) do begin
                        BT1:= TBorder(TT, B1);
                        if QTOwner[BT1] = P then C1:= C1 + 1;
                      end;
                      For B1:= 1 to TBordersCount(BT) do begin
                        BT1:= TBorder(BT, B1);
                        if QTOwner[BT1] = P then C2:= C2 + 1;
                      end;
                      if C2 < C1 then TT:= BT;
                      if C2 = C1 then begin
                        C1:= 0;
                        C2:= 0;
                        For B1:= 1 to TBordersCount(TT) do begin
                          BT1:= TBorder(TT, B1);
                          if QTOwner[BT1] = PMe then C1:= C1 + 1;
                        end;
                        For B1:= 1 to TBordersCount(BT) do begin
                          BT1:= TBorder(BT, B1);
                          if QTOwner[BT1] = PMe then C2:= C2 + 1;
                        end;
                        l('c1 ' +i(c1) + ' c2 ' + i(c2));
                        if C2 > C1 then begin
                          TT:= BT;
                          m('new tt: ' + i(tt));
                        end;
                      end;
                    end;
                //    l('bTT ' + i(TT));
                  end;
                end;
              end;
            end;
          end;
        end;
      end;

      if (TT = 0) and (DT > 0) and TIsBordering(FT, DT)
       and (not ( (QTArmies[FT] < 4) and (QTArmies[DT] > 1) )) then begin
        m('tt = 0 and dt = 0 and tisbordering, TT: ' + i(TT) + ' DT: ' + i(DT));
        TT:= DT;
      end;

      if NewFT > 0 then begin
        C:= 0;
        For n:= 1 to PL - 1 do if TT = Path[n] then C:= C + 1;

        if (C = 0) and (QTArmies[FT] > QTArmies[TT]) then m2('attack from secondary army, FT: ' + i(FT) + ' TT: ' + i(TT)) else begin
          if QTArmies[TT] > 2 then begin
            If SAlivePlayersCount > 2 then begin
              TT:= TT + 100;
              FT:= FT + 100;
            end;
            bs(98, TT);
            bs(99, FT);

            m2('attack from secondary army to weaken, FT: ' + i(FT) + ' TT: ' + i(TT));
          end else TT:= 0;
        end;
      end;
      Counter:= Counter + 1;
     // m2('counter ' + i(counter));
    Until (TT > 0) or (Counter > 2)
  end;
 //if ft = 27 then m('pause ft = 35 end');

  l('end TT ' + i(TT));
  if SAlivePlayersCount < 5 then m('pause');
end;

procedure ArmySort(var Army: array of integer);
var
  TC, x, x1, temp, T: integer;
begin
  SetArrayLength(Army, 43);
  For T:= 1 to 42 do Army[T]:= 0;
  TC:= 0;
  For T:= 1 to 42 do begin
    if TIsMine(T) then begin
      TC:= TC + 1;
      Army[TC]:= T;
    end;
  end;

  For x:= 1 to TC - 1 do begin
    For x1:= x + 1 to TC do begin
      if TArmies(Army[x1]) > TArmies(Army[x]) then begin
        temp:= Army[x];
        Army[x]:= Army[x1];
        Army[x1]:= temp;
      end;
    end;
  end;
end;

procedure QArmySort(var Army: array of integer; var QMyTC, QMyAC: integer);
var
  TC, x, x1, temp, T: integer;
begin
  SetArrayLength(Army, 43);
  For T:= 1 to 42 do Army[T]:= 0;
  QMyTC:= 0;
  QMyAC:= 0;
  For T:= 1 to 42 do begin
    if QTOwner[T] = PMe then begin
      QMyAC:= QMyAC + QTArmies[T];
      QMyTC:= QMyTC + 1;
      Army[QMyTC]:= T;
    end;
  end;

  For x:= 1 to QMyTC - 1 do begin
    For x1:= x + 1 to QMyTC do begin
      if QTArmies[Army[x1]] > QTArmies[Army[x]] then begin
        temp:= Army[x];
        Army[x]:= Army[x1];
        Army[x1]:= temp;
      end;
    end;
  end;
end;

Function QaddConnectedArmies(P, ST: integer; Var Armies, Ts: integer): boolean;
Var
  T, B, iNode, iChild: integer;

  aNode: array [1..42] of record
    bClosed: boolean;          // node is in the CLOSED list
    bOpen: boolean;            // node is in the Open list
  end;

begin
  Result:= False;
  Ts:= 0;
  Armies:= 0;

  if (ST = 0) then exit;

  for T:=1 to 42 do begin
    with aNode[T] do begin
      bClosed := false;
      bOpen:= false;
    end;
  end;

  aNode[ST].bopen := True;
  if QTOwner[ST] = P then begin
    Armies:= QTArmies[ST];
    Ts:= 1;
  end;

  Repeat
    T:= 0;
    iNode:= 0;
    repeat
      T:= T + 1;
      if aNode[T].bopen and not aNode[t].bClosed then begin
        iNode:= T;
      end;
    until (iNode > 0) or (T = 42);

    if iNode <> 0 then begin
      for B:= 1 to TBordersCount(iNode) do begin
        iChild:= TBorder(iNode, B);
        if (QTOwner[iChild] <> P) then continue;
        if ((not aNode[iChild].bOpen) and (not aNode[iChild].bClosed)) then begin
          Ts:= Ts + 1;
          Armies:= Armies + QTArmies[iChild];
          aNode[iChild].bOpen:= true;
        end;
      end;
    aNode[iNode].bClosed := true;
    end;

  until (iNode = 0);  // loop until there are no more open nodes

  if Ts > 0 then Result:= True;
  l('addCArmies: ' + i(Armies) + ' Ts: ' + i(Ts));

end;

Function AddConnectedArmies(P, ST: integer; Var Armies, Ts: integer): boolean;
Var
  T, B, iNode, iChild: integer;

  aNode: array [1..42] of record
    bClosed: boolean;          // node is in the CLOSED list
    bOpen: boolean;            // node is in the Open list
  end;

begin
  Result:= False;
  Ts:= 0;
  Armies:= 0;

  if (ST = 0) then exit;

  for T:=1 to 42 do begin
    with aNode[T] do begin
      bClosed := false;
      bOpen:= false;
    end;
  end;

  aNode[ST].bopen := True;
  if (TOwner(ST) = P) or ((P = 0) and (TOwner(ST) <> PMe)) then begin
    Armies:= TArmies(ST);
    Ts:= 1;
  end;

  Repeat
    T:= 0;
    iNode:= 0;
    repeat
      T:= T + 1;
      if aNode[T].bopen and not aNode[t].bClosed then begin
        iNode:= T;
      end;
    until (iNode > 0) or (T = 42);

    if iNode <> 0 then begin
      for B:= 1 to TBordersCount(iNode) do begin
        iChild:= TBorder(iNode, B);
        if (TOwner(iChild) = P) or ((P = 0) and (TOwner(iChild) <> PMe)) then begin;
          if ((not aNode[iChild].bOpen) and (not aNode[iChild].bClosed)) then begin
            Ts:= Ts + 1;
            Armies:= Armies + TArmies(iChild);
            aNode[iChild].bOpen:= true;
          end;
        end;
      end;
    aNode[iNode].bClosed := true;
    end;

  until (iNode = 0);  // loop until there are no more open nodes

  if Ts > 0 then Result:= True;
  //l('addCArmies: ' + i(Armies) + ' Ts: ' + i(Ts));

end;
{
Function QTIsFront(T: integer):boolean;
var
  b, bt: integer;
Begin
  Result:= False;
  For B:= 1 to TBordersCount(T) do begin
    BT:= TBorder(T, B);
    if QTOwner[BT] <> PMe then result:= True;
  end;
end;
}
Procedure KillWeakestPlayer(WP, LastTT: integer; var FromTerritory, ToTerritory: integer);
Var
  PL, TT1, Armies, Ts, T, TotalWPArmies, MyTotalArmies, X, MinDiff, TT, Y, B, BT,
  QPAC, CForce, EA, FT, QPTC, C, Cost, MinCost, DT: integer;
  WFA, Army: array of integer;
Begin
//    m('begin kill weakest player');
  QArmySort(Army, QPTC, QPAC);
  SetArrayLength(WFA, QPTC + 1);
  //l('QPTC ' + i(QPTC) + ' QPAC ' + i(QPAC));
  if bg(73) > 0 then begin
    Army[1]:= bg(73);
    QPTC:= 1;
  end;

  if LastTT > 0 then begin
    Army[1]:= LastTT;
    QPTC:= 1;
  end;

  For y:= 1 to QPTC do begin
//    m2('y: ' + i(y) + ' Army[y] ' + i(Army[y]) + ' armies: ' + i(QTArmies[Army[y]]));
    If (Army[y] = 31) then begin
      if (QTOwner[39] = WP) and (QTArmies[Army[y]] > 1)
       and (Not ( (QTArmies[Army[y]] < 4) and (QTArmies[39] > 1) )) then begin
        FromTerritory:= 31;
        ToTerritory:= 39;
        m('5 Army[y]: ' + i(Army[y]) + ' WP= ' + PProgram(WP) + ' ft: ' + i(fromterritory) + ' tt ' + i(toterritory));
        exit;
      end;
    end;

    WFA[y]:= 0;
    For B:= 1 to TBordersCount(Army[y]) do begin
      BT:= TBorder(Army[y], B);
      If QTOwner[BT] <> PMe then begin
        if (QTArmies[BT] < WFA[y]) or (WFA[y] = 0) then WFA[y]:= QTArmies[BT];
      end;
    end;
    if (WFA[y] > 0) and (QTArmies[Army[y]] > 1)
     and (Not ( (QTArmies[Army[y]] < 4) and (WFA[y] > 1) )) then begin
      C:= 0;
      For B:= 1 to TBordersCount(Army[y]) do begin
        BT:= TBorder(Army[y], B);
        If (QTOwner[BT] = WP) or ( (WP = 0) and (QTOwner[BT] <> PMe) ) then begin
          C:= C + 1;
          If C = 1 then TT:= BT else TT:= 0;
        end;
      end;
      If C = 1 then begin
        if (  not ( (QTArmies[TT] > 1) and (QTArmies[Army[y]] < 4) )  ) and ( (QTArmies[Army[y]] > QTArmies[TT]) or (SAlivePlayersCount = 2) ) then begin
          if (y > 1) and (SAlivePlayersCount > 2) then begin
            QaddConnectedArmies(WP, Army[y], Armies, Ts);
            if (QTArmies[Army[y]] > (Armies + Ts + (Ts div 3))) or (not QTWeakestPath(Army[1], TT, 1, TT1, PL, EA)) then begin
              ToTerritory:= TT;
              FromTerritory:= Army[y];
            end else m2('y > 1 Too many armies needed: ' + i((Armies + Ts + (Ts div 3))) + ' Army[y]: ' + i(Army[y]));

          end else begin
            ToTerritory:= TT;
            FromTerritory:= Army[y];
          end;
          {if QTArmies[ToTerritory] < 3 then }l('1 y: ' + i(y) + ' Army[y] ' + i(Army[y]) + ' WP= ' + PProgram(WP) + ' ft: ' + i(fromterritory) + ' tt ' + i(toterritory));
          if FromTerritory > 0 then exit;
        end;
      end else if c > 1 then begin
        FT:= Army[y];
        KillPlayerAttack2(WP, FT, TT);
        If TT > 0 then begin
          if (Y > 1) and( SAlivePlayersCount > 2) then begin
            if TT > 100 then begin
            //  QaddConnectedArmies(WP, (FT-100), Armies, Ts);
//              m2('is it here TT: ' + i(TT) + ' ft: ' + i(fT) + ' y: ' + i(y));
       //       if QTArmies[FT-100] > (Armies + (Ts div 3) - 2) then begin
                ToTerritory:= TT;
                FromTerritory:= FT;
       //       end;
            end else begin
              QaddConnectedArmies(WP, FT, Armies, Ts);
              if (QTArmies[FT] > (Armies + Ts + (Ts div 3))) or (not QTWeakestPath(Army[1], TT, 1, TT1, PL, EA)) then begin
                ToTerritory:= TT;
                FromTerritory:= FT;
              end else m2('y > 1 Too many armies needed: ' + i((Armies + Ts + (Ts div 3))) + ' FT: ' + i(FT));

            end;
          end else begin
            ToTerritory:= TT;
            FromTerritory:= FT;
          end;
          if ToTerritory > 0 then begin
            l('2 y: ' + i(y) + ' Army[y] ' + i(Army[y]) + ' WP= ' + PProgram(WP) + ' ft: ' + i(fromterritory) + ' tt ' + i(toterritory));
            exit;
          end;
        end;
      end;
      If C > 1 then begin
        if SAlivePlayersCount = 2 then m2('no attack found');
        {
        MinDiff:= 0;
        For B:= 1 to TBordersCount(Army[y]) do begin
          BT:= TBorder(Army[y], B);
          If (  (QTOwner[BT] = WP) or ( (WP = 0) and (QTOwner[BT] <> PMe) )   )
           and (not ( (QTArmies[BT] > 1) and (QTArmies[Army[y]] < 4) )) then begin
            if (trunc(abs(Army[y] - BT)) < MinDiff) or (MinDiff = 0) then begin
              MinDiff:= trunc(abs(Army[y] - BT));
              ToTerritory:= BT;
              FromTerritory:= Army[y];
              m('3 abs value attack, WP= ' + PProgram(WP) + ' ft: ' + i(fromterritory) + ' tt ' + i(toterritory));
            end;
          end;
        end;
        }
      end;
    end;  // end if QTArmies[Army[y]) > 1
  end; // For y:= 1 to QPTC

  MinCost:= 999999999;
  if (FromTerritory = 0) and (LastTT = 0) then begin
    // get this part to save the path and execute it so I only have to calculate it once
    For T:= 1 to 42 do if QTOwner[T] = WP then NeedToCheck[T]:= True else NeedToCheck[T]:= False;
    C:= 0;
    For y:= 1 to QPTC do begin
      if (WFA[y] > 0) and (QTArmies[Army[y]] > 3) then begin
        if WeakestPathToWP(WP, Army[y], TT, DT, Cost) then begin
          C:= C + 1;
          if (Cost < MinCost) and (Cost >= QTArmies[Army[y]]) then begin
            l('cost is too high, Cost: ' + i(cost));
          end;
          if (Cost < MinCost) and (Cost < QTArmies[Army[y]]) then begin
            if ( (FromTerritory > 0) and ( (MinCost - Cost) > (QTArmies[FromTerritory] - QTArmies[Army[y]]) ) or (FromTerritory = 0) ) then begin
              MinCost:= Cost;
              ToTerritory:= TT;
              FromTerritory:= Army[y];
              l('4 Army[y]: ' + i(Army[y]) + ' WP= ' + PName(WP) + ' ft: ' + i(fromterritory) + ' tt ' + i(toterritory) + ' cost ' + i(mincost));
            end;
          end;
        end;
      end;
    end;

    if Weaken1 then begin
      ConquestForce(CForce);
      if (MinCost > CForce) then begin
        ToTerritory:= 0;
        FromTerritory:= 0;
        l('cancel attack, MinCost > CForce, CForce: ' + i(CForce));
      end;
    end;

    if (C = 0) and (SAlivePlayersCount > 2) then begin
      m2('no possible way to kill WP: ' + PName(WP));
      if bg(87) = 0 then begin
        bs(87, WP);
      end else begin
        bs(88, WP);
      end;
    end;

    if (WP > 0) and (MinCost > 0) and (SAlivePlayersCount > 3) then begin
      TotalWPArmies:= 0;
      MyTotalArmies:= 0;
      For T:= 1 to 42 do begin
        if (QTOwner[T] = WP) then TotalWPArmies:= TotalWPArmies + QTArmies[T] + 1; // +1 to include a T count
      end;
      if MinCost + TotalWPArmies > QPAC - QPTC then begin
        FromTerritory:= 0;
        ToTerritory:= 0;
        l('*************************************************** savin time');
      end;
    end;
  end;
//  m('end of kill weakest player');
end;


Procedure AttackStrongPlayer(SP: integer; weaken: boolean; var FromTerritory, Toterritory: integer);
Var
  TurnInArmies, MinCostIOA, TotalCBonus, Cost, PL, EA, B, X, TT, MaxCost, MinCost, TargetEntryT, T, C: integer;

  SPEntryT: array of boolean;
  Army: array of integer;
begin
  // Repeat the last attack (speeds up performance)
  if (bg(100) > 0) then begin
    if (not ( (TArmies(bg(101)) < 4) and (TArmies(bg(100)) > 1) ))
     and (TArmies(bg(101)) > 1) and (TOwner(bg(101)) = PMe) and (TOwner(bg(100)) <> PMe) then begin
      if (not ( (bg(100) = bg(60)) and (TArmies(bg(60)) < 3) )) then begin  // get rid of this last part if I end up moving the last section to the occ procedure
        ToTerritory:= bg(100);
        FromTerritory:= bg(101);
        exit;
      end;
    end;
  end;

  SetArrayLength(SPEntryT, 43);
  ArmySort(Army);
  MinCost:= 0;
  if SCardsBasedOnCombo then MaxCost:= trunc(PArmiesCount(PMe) * 0.4) else MaxCost:= trunc(PArmiesCount(PMe) * 0.3);

  if (SAlivePlayersCount = 3) then MaxCost:= trunc(PArmiesCount(PMe) * 0.5);
  TargetEntryT:=0;
  For T:= 1 to 42 do SPEntryT[T]:= False;
  For C:= 1 to 6 do begin  // avoid australia, it's never worth it when australian owns it
    if (COwner(C) = SP) and (not ((C = 6) and (pos('australian', lowercase(PProgram(SP))) > 0))) then begin
      For B:= 1 to CEntriesCount(C) do begin
        For x:= 1 to PTC do begin
          if TArmies(Army[x]) > 3 then begin
            tt:= 0;
            if QTWeakestPath(Army[x], CEntry(C,B), 0, TT, PL, EA) then begin
              if SCardsBasedOnCombo then EA:= EA - TArmies(CEntry(C,B));
              SPEntryT[CEntry(C, B)]:= True;  // used later on if cost isn't less than mincost
              Cost:= PL + EA;
              if ((Cost < MinCost) or (MinCost = 0)) then MinCost:= Cost;
              if (Cost < MaxCost) then begin
                MinCost:= Cost;
                ToTerritory:= TT;
                FromTerritory:= Army[x];
                bs(100, ToTerritory);
                bs(101, FromTerritory);
                TargetEntryT:= CEntry(C, B);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
  if (MinCost > 0) and (FromTerritory = 0) and (not SConquest) then if m2('not attacking SP, MaxCost ' + i(maxcost) + ' mincost ' + i(mincost)) then exit;
  TotalCBonus:= 0;
  For C:= 1 to 6 do begin
    If COwner(C) = SP then TotalCBonus:= TotalCBonus + CBonus(C);
  end;
  if ( (TIV - PCardTurnInValue(SP)) > (3 * TotalCBonus) )
   and (MinCost > (TIV div 3)) then begin
    ToTerritory:= 0;
    FromTerritory:= 0;
    bs(100, 0);
    bs(101, 0);
    l('attack sp not worth it, high CTIV');
  end;

  If (FromTerritory > 0) then begin
    //m2('TET: ' + i(TargetEntryT));
      {The following code doesn't run until TargetEntryT is almost defeated}
    if (TArmies(ToTerritory) < 3) and (TArmies(FromTerritory) > 6) and (ToTerritory = TargetEntryT) then begin
      MinCost:= 0;
      MinCostIOA:= 0;  // IOA = if occupy all
      For C:= 1 to 6 do begin
        if (COwner(C) = SP) and (not (C = TContinent(ToTerritory)))then begin
          For B:= 1 to CEntriesCount(C) do begin
            if QTWeakestPath(TargetEntryT, CEntry(C,B), 0, TT, PL, EA) then begin
              Cost:= PL + EA;
              if ((Cost < MinCostIOA) or (MinCostIOA = 0)) and (Cost < MaxCost) then MinCostIOA:= Cost;
            end;
            For x:= 1 to PTC do begin
              if TArmies(Army[x]) > 3 then begin
                if QTWeakestPath(Army[x], CEntry(C,B), 0, TT, PL, EA) then begin
                  Cost:= PL + EA;
                  if ((Cost < MinCost) or (MinCost = 0)) and (Cost < MaxCost) then MinCost:= Cost;
                end;
              end;
            end;
          end;
        end;
      end;
      l('mincostIOA: ' + i(mincostIOA) + ' mincost: ' + i(mincost));
      EA:= 0;
      For x:= 1 to CTerritoriesCount(TContinent(TargetEntryT)) do begin
        EA:= EA + TArmies(CTerritory(TContinent(TargetEntryT), x));
      end;
      TurnInArmies:=0;
      if PCardCount(SP) > 2 then TurnInArmies:= PCardTurnInValue(SP);
      if (MinCostIOA > MinCost) or (  (MinCostIOA = 0) and ( (EA + TurnInArmies) > trunc(0.9*(TArmies(FromTerritory))) )  ) then begin
                                    // MinCostIOA = 0 implies that there are no more C's left to attack
        bs(67, 1);  // 67 - used to tell the occupation routine to set Armies:= 0
        l('dont occupy - mincostIOA: ' + i(mincostIOA) + ' mincost: ' + i(mincost));
      end;
      if (TContinent(TargetEntryT) = 6) then begin
        if (EA < TIV div 3) or (EA < 6) then bs(67, EA + 4)
         else bs(67, 1);
      end;
      l('bg 67: ' + i(bg(67)));
    end;

    if ToTerritory > 0 then l('attack SP: ' + PProgram(SP) + ' FT: ' + i(FromTerritory) + ' TT: ' + i(ToTerritory));
    if ToTerritory = TargetEntryT then begin
      m2('attack SP: ' + PProgram(SP) + ' FT: ' + i(FromTerritory) + ' TT: ' + i(ToTerritory));
      ///UTakeSnapshot('attack SP in australia');
    end;
    bs(60, TargetEntryT);
    exit;
  end else begin
    if weaken then begin
      InitializeQMap;
      KillWeakestPlayer(SP, 0, FromTerritory, ToTerritory);
      if ToTerritory > 0 then begin
        if ToTerritory > 100 then begin
          ToTerritory:= ToTerritory - 100;
          FromTerritory:= FromTerritory - 100;
        end;
        m2('weaken strong player');
        exit;
      end;
    end;
  end;
end;

Procedure AddConnectedTsArmies(MyArmy, T: integer; var CTArmies, Ts: Integer);
Var
  LowerCTArmies, MaxArmy, P, X, BT, C, B: integer;
  Open, Closed: array of boolean;
begin
  SetArrayLength(Closed, 43);
  SetArrayLength(Open, 43);

  For x:= 1 to 42 do begin
    Closed[x]:= False;
    Open[x]:= False;
  end;

  Open[T]:= True;
  CTArmies:= 0;
  Ts:= 0;
  MaxArmy:= 0;
  LowerCTArmies:= 0;
  Repeat
    if Open[T] and (not Closed[T]) then begin
      C:= 0;
      For B:= 1 to TBordersCount(T) do begin
        BT:= TBorder(T, B);
        if (TOwner(BT) <> PMe) and (not Open[BT]) then begin
          C:= C + 1;
          Open[BT]:= True;
        end;
        if (TOwner(BT) = PMe) and (not (BT = MyArmy)) and (TArmies(BT) > MaxArmy) and (TArmies(BT) > 3) then begin
          MaxArmy:= TArmies(BT);
          LowerCTArmies:= BT;
        end;
      end;
      Closed[T]:= True;
      CTArmies:= CTArmies + TArmies(T);
      Ts:= Ts + 1;
      if C > 0 then T:= 0;
    end;
    T:= T + 1;
  Until (T > 42);
  CTArmies:= CTArmies + Ts;
  if LowerCTArmies > 0 then begin
    CTArmies:= CTArmies - (TArmies(LowerCTArmies) - 1);
    if CTArmies < 0 then CTArmies:= 0;
  end;
end;

Function TsAreConnected(P, T, T1: integer): boolean;
Var
  X, BT, C, B: integer;
  TOwnerIsPlayerP, Checked: array of boolean;
begin
  SetArrayLength(Checked, 43);
  For x:= 1 to 42 do Checked[x]:= False;
  SetArrayLength(TOwnerIsPlayerP, 43);
  For x:= 1 to 42 do TOwnerIsPlayerP[x]:= False;

  Result:= False;
  TOwnerIsPlayerP[T]:= True;
  if (  not ( TIsMine(T1) and TIsMine(T) )  ) and TIsBordering(T, T1) then Result:= True;
  Repeat
    if TOwnerIsPlayerP[T] and (not Checked[T]) then begin
      C:= 0;
      For B:= 1 to TBordersCount(T) do begin
        BT:= TBorder(T, B);
        if ( (TOwner(BT) = P) or ((TOwner(BT) <> PMe) and (P = 0)) ) and (not TOwnerIsPlayerP[BT]) then begin
          C:= C + 1;
          TOwnerIsPlayerP[BT]:= True;
          if TIsBordering(BT, T1) then begin
            Result:= True;
            exit;
          end;
        end;
      end;
      Checked[T]:= True;
      if C > 0 then T:= 0;
    end;
    T:= T + 1;
  Until (T > 42);
end;

Function QTsAreConnected(P, T, T1: integer): boolean;
Var
  X, BT, C, B: integer;
  TOwnerIsPlayerP, Checked: array of boolean;
begin
  SetArrayLength(Checked, 43);
  For x:= 1 to 42 do Checked[x]:= False;
  SetArrayLength(TOwnerIsPlayerP, 43);
  For x:= 1 to 42 do TOwnerIsPlayerP[x]:= False;
  P:=0;    // this line is different from tsareconnected
  Result:= False;
  TOwnerIsPlayerP[T]:= True;
  if (  not ( (QTOwner[T1] = Pme) and (QTOwner[T] = PMe) )  ) and TIsBordering(T, T1) then Result:= True;
  Repeat
    if TOwnerIsPlayerP[T] and (not Checked[T]) then begin
      C:= 0;
      For B:= 1 to TBordersCount(T) do begin
        BT:= TBorder(T, B);
        if ( (QTOwner[BT] = P) or ((QTOwner[BT] <> PMe) and (P = 0)) ) and (not TOwnerIsPlayerP[BT]) then begin
          C:= C + 1;
          TOwnerIsPlayerP[BT]:= True;
          if TIsBordering(BT, T1) then begin
            Result:= True;
            exit;
          end;
        end;
      end;
      Checked[T]:= True;
      if C > 0 then T:= 0;
    end;
    T:= T + 1;
  Until (T > 42);
end;

Procedure ResetBuffers();
Begin
  bs(400, 0);
  bs(401, 0);
  bs(63, 0);
  bs(68, 0);
  bs(69, 0);
  bs(73, 0);
  bs(74, 0);
  bs(77, 0); // reset BestFT (KillPlayerOcc) - only used if BestFT is not connected to TT or FT
  bs(78, 0);
  bs(79, 0);
  bs(80, 0);
  bs(82, 0);
  bs(86, 0);
  bs(96, 0);
  bs(97, 0);
  bs(98, 0);
  bs(99, 0);
end;

Procedure KillPlayerOcc(P, FromTerritory, Toterritory: integer; Var Armies: integer);
Var
  ePAC, TT, MinCost, TTNeeds, FTNeeds, addCET_TT, addCET_FT, FTA, ePTC, T, B, iNode,
  B1, BT1, C1, FT, BestTT, FTNeedsMore, CForce, C, BT, MyTotalArmies, Cost, BestFT,
  BestDT, Ts, DT, TT_EA, FT_EA, iChild, MaxArmy, LowerFTNeeds: integer;
  addedFTNeedsMore, go: boolean;

  aNode: array [1..42] of record
    bClosed, bOpen, bTTOpen, cOpen, cClosed: boolean;
  end;
  //tempQTOwner: array [1..42] of integer;

begin
  //m('running KillPlayerOcc');
  //if FromTerritory = bg(77) then bs(77,0);  // stores bestFT

  bs(73, 0);
  bs(74, 0);
  l('P ' + i(p) + ' bg(77) ' + i(bg(77)) + ' bg(79) ' + i(bg(79)) + ' bg(80) ' + i(bg(80)) + ' bg(86) ' + i(bg(86)) + ' bg(96) ' + i(bg(96)) + ' bg(97) ' + i(bg(97)));
  if bg(400) > 0 then l('start kill player occ, FT ' + i(fromterritory) + ' TT ' + i(Toterritory));
  if ( (bg(80) = -1) and (FromTerritory = bg(77)) ) then begin
    bs(77, 0);
    bs(79, 0);
    bs(80, 0);
    bs(86, 0);
  end;

  FTA:= QTArmies[FromTerritory] - 1;

  // disable this shortcut if I ever figure out how to properly split with more than one split                                    // cant use shortcut if occupying to dead end
  if ((SAlivePlayersCount > 2) and (not KillBoth)) and (bg(97) = 0) then begin
    if ({c}({b}({a}(TOwner(ToTerritory) <> P) and (TOwner(ToTerritory) <> PMe){a}) and (bg(400) = 0){b}) or ( (bg(86) <> P) and (bg(86) > 04) ){c}) then begin
      Armies:= FTA;
      l('armies = FTA occ **************************************************************');
      exit;
    end;
  end;

  ConquestForce(CForce);
  Armies:= 0;
  {
  if ToTerritory = bg(74) then begin
    m('occupy all');
    Armies:= FTA;
    bs(73, 0);
    bs(74, 0);
    exit;
  end;
  }

  //if FromTerritory  = 22 then m2('pause');
  // optimized code for Australia
  if (ToTerritory = 39) and (FromTerritory = 31) then begin
    if PTerritoriesCount(PMe) > 38 then begin
      Armies:= FTA;
      exit;
    end;
    if P = 0 then begin
      For T:= 40 to 42 do if QTOwner[T] <> PMe then Armies:= Armies + QTArmies[T] + 1 else Armies:= Armies - (QTArmies[T] - 1);
      if (not(Armies = 6)) and (SAlivePlayersCount = 3) then Armies:= Armies + 3;
    end else begin
      For T:= 40 to 42 do if QTOwner[T] = P then Armies:= Armies + QTArmies[T] + 1;
      if (not(Armies = 6)) and (SAlivePlayersCount = 3) then Armies:= Armies + 3;
      if (QTOwner[41] = P) and (QTOwner[40] <> P) and (QTOwner[42] <> P) then
       if QTArmies[42] < QTArmies[40] then Armies:= Armies + QTArmies[42] + 1 else
        Armies:= Armies + QTArmies[40] + 2;
    end;
    Armies:= Armies + 1;
    If Armies > FTA then Armies:= FTA;
    if Armies < 0 then Armies:= 0;
    m('Aus occ, armies: ' + i(Armies));
    exit;
  end;

  ePTC:= 0; // enemy player territory count
  ePAC:= 0; // enemy player army count
  for T:=1 to 42 do begin
    if QTOwner[T] = P then begin
      ePTC:= ePTC + 1;
      ePAC:= ePAC + QTArmies[T];
    end;
    with aNode[T] do begin
      bClosed := false;
      bOpen:= false;
      bTTOpen:= false;
      cOpen:= false;
      cClosed:= false;
    end;
  end;

  if (ePTC = 0) and (not (P = 0)) then begin
// add code to switch to next weakest player
    Armies:= FTA;
    l('new occ code player is dead ePTC = 0');
    exit;
  end;

  TTNeeds:= 0;
  TT_EA:= 0;
  aNode[ToTerritory].bTTopen := True;
  addCET_TT:= 0;  // add connected enemy territories - ToTerritory
  Repeat
    T:= 0;
    iNode:= 0;
    repeat
      T:= T + 1;
      if aNode[T].bTTopen and not aNode[T].bClosed then begin
        iNode:= T;
      end;
    until (iNode > 0) or (T = 42);

    if iNode > 0 then begin
      for B:= 1 to TBordersCount(iNode) do begin
        iChild:= TBorder(iNode, B);
        if (QTOwner[iChild] <> P) or ( (P = 0) and (QTOwner[iChild] = PMe) ) then continue;
        if ((not aNode[iChild].bTTOpen) and (not aNode[iChild].bClosed)) then begin
          addCET_TT:= addCET_TT + 1;
          TTNeeds:= TTNeeds + QTArmies[iChild] + 1;
          TT_EA:= TT_EA + QTArmies[iChild];
          aNode[iChild].bTTOpen:= true;
        end;
      end;
    aNode[iNode].bClosed := true; // node has been examined, add to CLOSED list
    end;
  until (iNode = 0);  // loop until there are no more open nodes
  TTNeeds:= TTNeeds + addCET_TT div 3;

  if bg(96) > 0 then For B:= 1 to TBordersCount(bg(96)) do begin
    BT:= TBorder(bg(96), B);
    if (not (BT = FromTerritory)) and (QTOwner[BT] = PMe) then begin
      if QTArmies[BT] > QTArmies[bg(96)] then TTNeeds:= TTNeeds - QTArmies[bg(96)] - 1
       else if (QTArmies[bg(96)] > 2) and (QTArmies[BT] > 2) then TTNeeds:= TTNeeds - (QTArmies[BT] - 2);
      break;
    end;
  end;

  if addCET_TT = ePTC then begin
    Armies:= FTA;
    l('new occ code only tt needs');
    if bg(97) = 0 then exit;
  end;

  FTNeeds:= 0;
  FT_EA:= 0;
  aNode[FromTerritory].bOpen:= True;
  addCET_FT:= 0;
  MaxArmy:= 0;
  LowerFTNeeds:= 0;
  Repeat
    T:= 0;
    iNode:= 0;
    repeat
      T:= T + 1;
      if aNode[T].bopen and not aNode[T].bClosed then begin
        iNode:= T;
      end;
    until (iNode > 0) or (T = 42);

    if iNode > 0 then begin
      for B:= 1 to TBordersCount(iNode) do begin
        iChild:= TBorder(iNode, B);
        if {((QTOwner[iChild] <> P) or ( (P = 0) and (QTOwner[iChild] = PMe) ))
         or }aNode[iChild].bClosed then continue;  // don't add armies from T's connected to ToTerritory
        if (QTOwner[iChild] = P) or ( (P = 0) and (QTOwner[iChild] <> PMe) ) then begin
          if ((not aNode[iChild].bOpen) and (not aNode[iChild].bClosed)) then begin
            addCET_FT:= addCET_FT + 1;
            FTNeeds:= FTNeeds + QTArmies[iChild] + 1;
            FT_EA:= FT_EA + QTArmies[iChild];
            aNode[iChild].bOpen:= true;
          end;
        end;
        if (QTOwner[iChild] = PMe) and (QTArmies[iChild] > 3) and (QTArmies[iChild] > MaxArmy) then begin
          MaxArmy:= QTArmies[iChild];
          LowerFTNeeds:= iChild;
        end;
      end;
      aNode[iNode].bClosed := true; // node has been examined, add to CLOSED list
    end;
  until (iNode = 0);  // loop until there are no more open nodes

  FTNeeds:= FTNeeds + addCET_FT div 3;
  addedFTNeedsMore:= False;
  if (bg(77) > 0) and (FTNeeds > 0) then begin
    if aNode[bg(77)].bopen then FTNeeds:= FTNeeds + bg(79);
    addedFTNeedsMore:= True;
    m2('add ftNeedsMore to FTNeeds');
  end;

  if LowerFTNeeds > 0 then begin
    m('Before LowerFTNeeds, FTNeeds = ' + i(FTNeeds));

    FTNeeds:= FTNeeds - (QTArmies[LowerFTNeeds] - 1);
    If FTNeeds < 0 then FTNeeds:= 0;

    aNode[LowerFTNeeds].cOpen:= True;
    Repeat
      T:= 0;
      iNode:= 0;
      repeat
        T:= T + 1;
        if aNode[T].cOpen and not aNode[T].cClosed then begin
          iNode:= T;
        end;
      until (iNode > 0) or (T = 42);

      if iNode > 0 then begin
        for B:= 1 to TBordersCount(iNode) do begin
          iChild:= TBorder(iNode, B);
          if {((QTOwner[iChild] <> P) or ( (P = 0) and (QTOwner[iChild] = PMe) ))
           or }aNode[iChild].cClosed then continue;  // don't add armies from T's connected to ToTerritory
          if (QTOwner[iChild] = P) or ( (P = 0) and (QTOwner[iChild] <> PMe) ) then begin
            if ((not aNode[iChild].cOpen) and (not aNode[iChild].cClosed)) then begin
              aNode[iChild].cOpen:= true;
            end;
          end;
        end;
        aNode[iNode].cClosed := true; // node has been examined, add to CLOSED list
      end;
    until (iNode = 0);  // loop until there are no more open nodes
    For T:= 1 to 42 do begin
      if (aNode[T].bOpen) and (QTOwner[T] = P) and not aNode[T].cOpen then begin
        FTNeeds:= FTNeeds + QTArmies[T] + 1;
        //l('t: ' + i(T));
      end;
    end;
    m('After LowerFTNeeds, FTNeeds = ' + i(FTNeeds));
  end;

  if FTNeeds < 0 then FTNeeds:= 0;
  if FTNeeds = 2 then FTNeeds:= 3;

  if FTNeeds = 0 then Armies:= FTA;

  if (FTNeeds > 0) then begin
    {if (TTNeeds > 0) then }Armies:= FTA - FTNeeds;
    if ToTerritory = bg(82) then begin
      bs(82, 0);
      Armies:= TTNeeds;
    end else begin
      if bg(96) > 0 then begin
        if aNode[bg(96)].bOpen then begin
          Armies:= TTNeeds;
          if bg(400) = 0 then bs(82, ToTerritory);
        end;
      end else begin
        if bg(97) > 0 then begin
          if aNode[bg(97)].bOpen then Armies:= TTNeeds;
          if bg(400) = 0 then bs(82, ToTerritory);
        end;
      end;
    end;
    if (Armies = TTNeeds) and (Armies > 0) then begin
      l('armies = ttneeds');
      if FTA > TTNeeds + FTNeeds + 4 then begin
        Armies:= Armies + 2;
        TTNeeds:= TTNeeds + 2;
        l('give TT 2 extra');
      end;
      if (FTA > TTNeeds + FTNeeds + 5) and (SAlivePlayersCount = 3) then begin
        Armies:= Armies + 3;
        TTNeeds:= TTNeeds + 3;
        l('give TT 3 extra');
      end;
    end;
    if Armies > FTA then Armies:= FTA;
  end;

  // dont know what this code was for but i disabled it because it screwed something else up
  {
  if (TFrontsCount(FromTerritory) = 1) and (TArmies(TFront(FromTerritory, 1)) > FTA) then begin
    Armies:= TTNeeds + 3;
    if Armies > FTA then Armies:= FTA;
    m2('my armies are less than, Armies: ' + i(armies));
    exit;
  end;
  if (TFrontsCount(ToTerritory) = 1) and (TArmies(TFront(ToTerritory, 1)) > FTA) then begin
    Armies:= FTNeeds + 3;
    if Armies > FTA then Armies:= FTA;
    m2('my armies are less than, Armies: ' + i(armies));
    exit;
  end;
  }

  l('ttNeeds:  ' + i(TTNeeds) + ' FTNeeds: ' + i(ftneeds));

  if (TTNeeds = 0) and (FTNeeds > 0) then begin
    C:= 0;
    C1:= 0;
    For B:= 1 to TBordersCount(ToTerritory) do begin
      BT:= TBorder(ToTerritory, B);
//      if QTOwner[BT] = P then C:= C + 1;
      if (QTOwner[BT] <> PMe) and (QTArmies[BT] < CForce) then C1:= C1 + 1;
    end;
    {
    if C = 0 then begin
      if ToTerritory = bg(96) then begin  // if ToTerritory = DT
        Armies:= FTA - FTNeeds;
        if Armies < 0 then Armies:=0;
        m('toterritory = bg(96)');
      end else Armies:= 0;
    end else Armies:= FTA - FTNeeds;
    }
    if C1 = 0 then begin
      Armies:= 0;
      l('new occ code ttneeds = 0 - no attack possible from TT');
    end;
  end;

  if (Armies > TTNeeds + 2) and (FTNeeds > 1) and ((addCET_FT > 1) or addedFTNeedsMore) then begin
    if (addCET_FT < 3) and (not addedFTNeedsMore) then begin
      Armies:= Armies - (addCET_FT);
      FTNeeds:= FTNeeds + (addCET_FT);
    end else begin
      Armies:= Armies - 3;
      FTNeeds:= FTNeeds + 3;
    end;
    m('give FT extra, FTNeeds: ' + i(FTNeeds) + ' Armies:= ' + i(Armies));
    if (SAlivePlayersCount = 3) and (FTA > TTNeeds + FTNeeds + 2) then begin
      Armies:= Armies - 3;
      FTNeeds:= FTNeeds + 3;
      m('give FT more extra, FTNeeds: ' + i(FTNeeds) + ' Armies:= ' + i(Armies));
    end;
    if Armies < 0 then Armies:=0;
  end;
                                                                                                                            // old owner
  if (bg(77) = 0) then if ((SAlivePlayersCount > 2) and (not KillBoth)) then if (addCET_TT + addCET_FT < ePTC) and ( ((TOwner(ToTerritory) = P) and (bg(400) = 0)) or (bg(86) = P) ) then begin
    FTNeedsMore:= 0;
    BestFT:= 0;
    BestTT:= 0;

    For T:= 1 to 42 do if (QTOwner[T] = P) and (aNode[T].bclosed = false) then begin
      NeedToCheck[T]:= True;
      //if FromTerritory = 22 then umessage('T ' + i(T));
    end else NeedToCheck[T]:= False;
    MinCost:= 999999999;
    For T:= 1 to 42 do begin
      if aNode[T].bClosed or
       ( (QTOwner[T] = PMe) and (QTArmies[T] > (EPAC - FT_EA - TT_EA) + (EPTC - addCET_FT - addCET_TT) + ((EPTC - addCET_FT - addCET_TT) div 3)) )then begin

       //   if FromTerritory = 22 then umessage('T ' + i(T));
          //m2('T ' + i(t));
          if WeakestPathToWP(P, T, TT, DT, Cost) then begin  // cost includes Ts div 3
            if (Cost < MinCost) then begin
              MinCost:= Cost;
              BestFT:= T;
              BestTT:= TT;
              BestDT:= DT;
        //      l('1 bestFT: ' + i(T) + ' bestTT: ' + i(TT) + ' bestDT: ' + i(DT));
            end else begin
              if (Cost = MinCost) and (not (T = FromTerritory)) then begin
                BestFT:= T;
                BestTT:= TT;
                BestDT:= DT;
          //      l('2 bestFT: ' + i(T) + ' bestTT: ' + i(TT) + ' bestDT: ' + i(DT));
              end;
            end;
       //   end;
        end;
      end;
    end;
    if QTOwner[BestTT] = P then bs(80, -1) else begin
      if BestFT > 0 then begin
        QaddConnectedArmies(P, BestDT, FTNeedsMore, Ts);
        //FTNeedsMore:= (EPAC - FT_EA - TT_EA) + (EPTC - addCET_FT - addCET_TT) + ((EPTC - addCET_FT - addCET_TT) div 3) + MinCost;
        FTNeedsMore:= FTNeedsMore + MinCost + Ts + (Ts div 3);
        bs(80, BestTT);
        bs(79, FTNeedsMore);
        bs(77, BestFT);
      end else bs(77, -1);
    end;
    l('weakest path occ, FT: ' + i(FromTerritory) + ' Bestft: ' + i(bestFT) + ' MinCost ' + i(mincost) + ' FTNeedsMore ' + i(FTNeedsMore));
  end;
                                                                                        // only run this code if the bestFT is not already connected to Player P
  if (bg(77) > 0) and ( (bg(77) = FromTerritory) or (bg(77) = ToTerritory) ) and (not (bg(80) = -1)) then begin
    BestFT:= bg(77);
    FTNeedsMore:= bg(79);
    MyTotalArmies:= 0;
    For T:= 1 to 42 do begin
      if QTOwner[T] = PMe then MyTotalArmies:= MyTotalArmies + QTArmies[T] - 1;  // -1 to exclude my t count
    end;
    l('FTNeedsMore ' + i(FTNeedsMore));
    if (TTNeeds + FTNeeds + FTNeedsMore > MyTotalArmies) and (bg(400) = 0) and (SAlivePlayersCount > 3) then begin
      Armies:= -1000;
      l('*************************************************** savin time occ');
    end else begin
//      if not aNode[BestFT].bClosed then bs(77, BestFT);
      if (FromTerritory = BestFT) then begin
        //l('epac ' + i(EPAC));
        //l('addCET_TT ' + i(addCET_TT));
//        m2('bestFT');
        if (FTNeeds <= 0) and (ToTerritory = bg(80)) then begin
          Armies:= FTA;
          m2('ttneeds = 0, ftneeds = 0, armies:= fta');
        end else begin
          if FTNeeds + FTNeedsMore > TTNeeds then begin
            Armies:= TTNeeds;
            if FTA > FTNeeds + FTNeedsMore + TTNeeds + 5 then Armies:= Armies + 3;
            if Armies > FTA then Armies:= FTA;
          end else Armies:= FTA - FTNeeds - FTNeedsMore;
          m('new occ3, Armies:= ' + i(Armies));


          if (Armies > TTNeeds + 4) and (FTNeedsMore > 3) then begin
            Armies:= Armies - 3;
            m('FTNeedsMore, give FT 3 extra, Armies:= ' + i(Armies));
          end;

          if Armies < 0 then Armies:=0;
        end;
      end;

      if ToTerritory = BestFT then begin
        Armies:= FTA - FTNeeds;
        m('new occ4, Armies:= ' + i(Armies));
        if (Armies > FTNeedsMore + 2) and (FTNeeds > 5) then begin
          Armies:= Armies - 3;
          m('FTNeeds, give FT 3 extra, Armies:= ' + i(Armies));
        end;
        if Armies < 0 then Armies:=0;
      end;

    end;
  end;

  if (Armies < FTA) and (Armies > 0) {just in case Armies = -1000} then begin
    //m('start bs 73');
    C:= 0;
    For B:= 1 to TBordersCount(FromTerritory) do begin
      BT:= TBorder(FromTerritory, B);
      if (QTOwner[BT] = P) and aNode[BT].bTTopen and (not (BT = ToTerritory)) then C:= C + 1;
    end;
    if C > 0 then begin
      //m('C>0');
      //For T:= 1 to 42 do tempQTOwner[T]:= 0;
      For B:= 1 to TBordersCount(FromTerritory) do begin
        BT:= TBorder(FromTerritory, B);
        if (QTOwner[BT] = P) and aNode[BT].bTTopen and (not (BT = ToTerritory)) then begin
          //tempQTOwner[BT]:= P;
          QTOwner[BT]:= 0;
        end;
      end;
      if addCET_FT = 0 then begin
        bs(73, FromTerritory);
        bs(74, bg(80));  // 80 - bestTT
      end else begin
        FT:= FromTerritory;
        bs(73, FromTerritory);
        KillWeakestPlayer(P, 0, FT, TT);
        if ft <> FromTerritory then m('ft <> FromTerritory, FT: ' + i(fT));
        if TT > 0 then bs(74, TT) else begin
          bs(73, 0);
          bs(74, 0);
        end;
      end;
      For B:= 1 to TBordersCount(FromTerritory) do begin
        BT:= TBorder(FromTerritory, B);
        //if tempQTOwner[BT] > 0 then QTOwner[BT]:= tempQTOwner[BT];
        if QTOwner[BT] = 0 then QTOwner[BT]:= P;
      end;
    end;
  end;

  if (bg(97) > 0) and (TTNeeds > 0) and (SAlivePlayersCount > 2) and (bg(97) <> bg(78)) then begin
//  m2('begin new code');
    C:= 0;
    For B:= 1 to TBordersCount(FromTerritory) do begin
      BT:= TBorder(FromTerritory, B);
      if (QTOwner[BT] <> PMe) and (QTOwner[BT] <> P) then C:= C + 1;
    end;
  //  m2('1 C ' + i(C));
    if (C > 0) and (bg(97) < 39) then begin
      C:= 0;
      For B:= 1 to TBordersCount(bg(97)) do begin
        BT:= TBorder(bg(97), B);
        if QTOwner[BT] = PMe then begin
          For B1:= 1 to TBordersCount(BT) do begin
            BT1:= TBorder(BT, B1);
            if (QTOwner[BT1] <> PMe) and (QTOwner[BT1] <> P) then C:= C + 1;
          end;
        end;
      end;
   // m2('2 C ' + i(C));

      If C = 0 then begin
        Armies:= TTNeeds + 6;
        if SAlivePlayersCount = 3 then TTNeeds:= TTNeeds + 10;
        if Armies > FTA then Armies:= FTA;
        if bg(400) > 0 then m2('dont occupy to a dead end');
        bs(78, bg(97));
      end;
    end;
  end;

  if ((BestFT > 0) and (BestFT = FromTerritory)) {or ( (bg(80) = -1) and (FromTerritory = bg(77)) )} then begin
    bs(77, 0);
    bs(79, 0);
    bs(80, 0);
  end;
  if ToTerritory = bg(97) then bs(97, 0);
  //bs(86, 0);
end;

Function PathToClosestWeakFront(ST: integer; var TT, DT, PL: integer): boolean;
            {or ClosestWeakerFront in some cases}
Var
  CForce, T: integer;

  B, iNode, iChild, iCostFromStart: integer;

  Cost, MinCost: double;

  aNode: array [1..42] of record
    bClosed: boolean;          // node is in the CLOSED list
    bOpen: boolean;            // node is in the Open list
    iParent: integer;          // previous node in the optimal path
    iCostFromStart: integer;   // cost to arrive to this node
  end;
  
begin
  ConquestForce(CForce);
  result:= False;
  TT:= 0;
  DT:= 0;
  PL:= 0;
  MinCost:= 0;

  // The following code was modified from some code that Mario shared with me from his path functions
  for T:=1 to 42 do begin
    with aNode[T] do begin
      bClosed := false;
      bOpen:= false;
    end;
  end;

  aNode[ST].iParent := 0;
  aNode[ST].iCostFromStart := 0;
  aNode[ST].bopen := True;

  Repeat
    T:= 0;
    iNode:= 0;
    repeat
      T:= T + 1;
      if aNode[T].bopen and not aNode[t].bClosed then begin
        iNode:= T;
      end;
    until (iNode > 0) or (T = 42);

    if (iNode > 0) then begin
      for B:= 1 to TBordersCount(iNode) do begin
        iChild:= TBorder(iNode, B);

        if (TOwner(iChild) <> PMe) then begin
          if TArmies(iChild) < CForce then begin
            Cost:= aNode[iNode].iCostFromStart - 1/double(TArmies(iChild));
            if (Cost < MinCost) or (MinCost = 0) then begin
              MinCost:= Cost;
              DT:= iChild;
            end;
          end;
        end;

        if (TOwner(iChild) = PMe) or (iChild = DT) then begin
          iCostFromStart := aNode[iNode].iCostFromStart + 1;
          // assign cost to child if end node has not been reached already
          // or if reached with higher cost
          if ((not aNode[iChild].bOpen) and (not aNode[iChild].bClosed))
          or (iCostFromStart < aNode[iChild].iCostFromStart) then begin
            aNode[iChild].iParent := iNode;
            aNode[iChild].iCostFromStart := iCostFromStart;
            if aNode[iChild].bClosed then aNode[iChild].bClosed:= false; // if closed then remove child from CLOSED list
            if not aNode[iChild].bOpen then aNode[iChild].bOpen:= true;  // add to open list
          end;
        end;
      end;
      aNode[iNode].bClosed := true; // node has been examined, add to CLOSED list
    end;
    // end of Mario's modified code
  until iNode = 0;

  if DT > 0 then begin
    Result:= True;
    iNode:= DT;
    PL:= aNode[iNode].iCostFromStart;

    while (aNode[iNode].iParent > 0) and (aNode[iNode].iParent <> ST) do begin
      iNode := aNode[iNode].iParent;
    end;

    TT:= iNode;
  end;

  if TT = ST then begin
//    m('already at best front');
    TT:= 0;
    DT:= 0;
    PL:= 0;
    Result:= False
  end;
  m2('end result: TT: ' + i(TT) + ' PL: ' + i(PL) + ' DT: ' + i(DT) + ' TArmies(DT) ' + i(TArmies(DT)) + ' CForce ' + i(CForce));
end;


procedure SortEnemyT(var EnemyT: array of integer; sort: integer);
var                                                // for ascending set sort = 1, sort = 0 for descending
  TC, x, x1, temp, T: integer;
begin
  TC:= 42 - PTerritoriesCount(Pme);
  SetArrayLength(EnemyT, 43);
  For T:= 1 to 42 do EnemyT[T]:= 0;
  x:= 0;
  For T:= 1 to 42 do begin
    if (Not TIsMine(T)) and (not (TContinent(T) = 2)) and (not (TContinent(T) = 6)) then begin
      x:= x + 1;
      EnemyT[x]:= T;
    end;
  end;
  For x:= 1 to TC - 1 do begin
    For x1:= x + 1 to TC do begin
      if (sort = 0) and (TArmies(EnemyT[x1]) > TArmies(EnemyT[x])) then begin
        temp:= EnemyT[x];
        EnemyT[x]:= EnemyT[x1];
        EnemyT[x1]:= temp;
      end;
      if (sort = 1) and (TArmies(EnemyT[x1]) < TArmies(EnemyT[x])) then begin
        temp:= EnemyT[x];
        EnemyT[x]:= EnemyT[x1];
        EnemyT[x1]:= temp;
      end;
    end;
  end;
end;


{ // this procedure adds path length and destination front to TPathToFront
procedure PathToFront(T: integer; var Front, PL: Integer);
begin
  PL:= 0;
  front:= T;
  if not TIsFront(Front) then begin
    Repeat
      front:= TPathToFront(Front)
      PL:= PL + 1;
    Until TIsFront(Front) or (PL > 20);
  end;
end;
}

procedure TWithWeakestFront(var TWF, WF, WeakestFrontA: integer);
var
  T, ET, EA: integer;
begin
  WeakestFrontA:= 0;
  TWF:= 0;
  WF:= 0;
  For T:= 1 to 42 do begin
    if TIsFront(T) {and (TArmies(T) > 3)} then begin
      TWeakestFront(T, ET, EA);
    //  if TArmies(T) > EA then begin
        if (EA < WeakestFrontA) or (WeakestFrontA = 0) then begin
          WeakestFrontA:= EA;
          TWF:= T;
          WF:= ET;
        end;
        if EA = WeakestFrontA then if TArmies(T) > TArmies(TWF) then begin
          TWF:= T;
          WeakestFrontA:= EA;
          WF:= ET;
        end;
      //end;
    end;
  end;
end;

procedure RankSort(var Rank: array of integer);
var
  temp, APC, x, x1, P: integer;
begin
  x:= 0;
  SetArrayLength(Rank, 11);
  For P:= 1 to 10 do Rank[P]:= 0;
  For P:= 1 to 10 do begin
    if (PArmiesCount(P) > 0) then begin
      x:= x + 1;
      Rank[x]:= P;
    end;
  end;
  APC:= SAlivePlayersCount;
  For x:= 1 to APC - 1 do begin
    For x1:= x + 1 to APC do begin
      if PArmiesCount(Rank[x1]) > PArmiesCount(Rank[x]) then begin
        temp:= Rank[x];
        Rank[x]:= Rank[x1];
        Rank[x1]:= temp;
      end;
    end;
  end;
end;

procedure cRankSort(var Rank, PArmies: array of integer; var MyArmies: integer);
var
  temp, APC, x, x1, P: integer;
begin
  x:= 0;
  SetArrayLength(Rank, 11);
  SetArrayLength(PArmies, 11);
  For P:= 1 to 10 do Rank[P]:= 0;
  For P:= 1 to 10 do begin
    if (PArmiesCount(P) > 0) then begin
      x:= x + 1;
      Rank[x]:= P;
      PArmies[x]:= PArmiesCount(Rank[x]) + PNewArmies(Rank[x]) + trunc(double(PCardCount(Rank[x]))/3 * double(PCardTurnInValue(Rank[x])));
    end;
  end;
  APC:= SAlivePlayersCount;
  For x:= 1 to APC - 1 do begin
    For x1:= x + 1 to APC do begin
//      PArmiesX1:= PArmiesCount(Rank[x1]) + trunc(double(PCardCount(Rank[x1]))/3 * double(PCardTurnInValue(Rank[x1])));
//      PArmiesX:= PArmiesCount(Rank[x]) + trunc(double(PCardCount(Rank[x]))/3 * double(PCardTurnInValue(Rank[x])));
      if PArmies[X1] > PArmies[X] then begin
        temp:= Rank[x];
        Rank[x]:= Rank[x1];
        Rank[x1]:= temp;
        temp:= PArmies[x];
        PArmies[x]:= PArmies[X1];
        PArmies[x1]:= temp;
      end;
    end;
  end;
  For x:= 1 to APC do if Rank[x] = PMe then MyArmies:= PArmies[x];
end;

Function CEA(var C: integer): integer;  // continents total enemy armies
var x: integer;
begin
  result:= 0;
  For x:= 1 to CTerritoriesCount(C) do begin
    If not TIsMine(CTerritory(C, x)) then result:= result + TArmies(CTerritory(C, x));
  end;
end;

Function CPT(var C: integer): integer;  // total territories owned on continent C
var x: integer;
begin
  result:= 0;
  For x:= 1 to CTerritoriesCount(C) do begin
    If TIsMine(CTerritory(C, x)) then result:= result + 1;
  end;
end;

Function AIFD(var T: integer): boolean;  // Army is for defence
Begin
  if (COwner(TContinent(T)) = PMe) and TIsEntry(T) then result:= True else result:= false;
end;

Procedure KillWeakPlayerCheck(var WP: integer; PathCostTotal: integer; var KillWP: boolean; rank: array of integer);
Var
  MaxTIV, KillValue, temp, PArmiesX, PArmiesX1, x1, P, APC, MyArmies, x, extra, OP: integer;
  TM: double;
  PArmies: array of integer;
Begin
  KillWP:= False;  // KillWP = kill weakest player

  if SAlivePlayersCount > 4 then begin


    Extra:= 25 - TIV;
    if Extra < 10 then Extra:= 10;
    KillValue:= round(double(TIV) * double(PCardCount(WP))/3);

    If (PCardCount(Pme) + PCardCount(WP) >= 5)
     and (PArmiesCount(PMe) + PNewArmies(PMe) - PTerritoriesCount(PMe) > PArmiesCount(WP) + PTerritoriesCount(WP) + Extra)
      then KillWP:= True;

    If (PCardCount(WP) > 2)
     and ( (PArmiesCount(PMe) + PNewArmies(PMe)) - (PArmiesCount(WP) + Extra) >  PArmiesCount(Rank[(SAlivePlayersCount div 2) + 1]) )
      then KillWP:= True;

    If (Rank[1] = PMe) and (SAlivePlayersCount <= 4) and (PCardCount(Pme) + PCardCount(WP) >= 5)
     and (TIV >= PArmiesCount(WP)) then KillWP:= True;

    if (KillValue > PArmiesCount(WP))
     and (PArmiesCount(PMe) + PNewArmies(PMe) - PTerritoriesCount(PMe) > PArmiesCount(WP) + PTerritoriesCount(WP) + Extra) then begin
      if not killwp then if m2('killvalue > WP Armies') then exit;
      KillWP:= True;
    end;

    if KillWP and (PCardCount(Pme) + PCardCount(WP) <= 4) then begin
      cRankSort(rank, parmies, myarmies);
//      For x:= 1 to saliveplayerscount do l('Rank ' + i(x) + ': ' + PName(Rank[x]) + ' Armies: ' + i(PArmies[x]));
      MyArmies:= PArmiesCount(PMe) + PNewArmies(PMe) - (PArmiesCount(WP) + 5)
       + trunc(double(PCardCount(PMe) + PCardCount(WP))/3 * double(TIV)) + 10; // add the plus 10 to favor killing in the early game when numbers are low
      if (Rank[1] <> PMe) then begin
        if (Rank[2] <> PMe) then begin
          if double(PArmies[1] - MyArmies) / PArmies[1] > 0.30 then begin
            KillWP:= False;
            m2('1 new abort killwp, Ratio: ' + f(double(PArmies[1] - MyArmies) / PArmies[1]));
          end;
          if double(PArmies[1] - PArmies[2]) / PArmies[1] > 0.15 then begin
            KillWP:= False;
            m2('2 new abort killwp, Ratio: ' + f(double(PArmies[1] - PArmies[2]) / PArmies[1]));
          end
        end;
        if (Rank[2] = PMe) then begin
          if (double(PArmies[1] - MyArmies) / PArmies[1] > 0.20) and (double(PArmies[1] - PArmies[3]) / PArmies[1] > 0.30) then begin
            KillWP:= False;
            m2('3 new abort killwp, Ratio: ' + f(double(PArmies[1] - MyArmies) / PArmies[1]));
          end
        end;
      end;
      {
      if KillWP then begin
        MyArmies:= PArmiesCount(PMe) + PNewArmies(PMe) - (PArmiesCount(WP)) + TIV;
        if MyArmies + 10 <= PArmies[(SAlivePlayersCount div 2) + 1] then begin
          KillWP:= False;
          m2('4 new abort Killwp, MyArmies: ' + i(myArmies) + ' PArmies[(SAlivePlayersCount div 2) + 1] ' + i(PArmies[(SAlivePlayersCount div 2) + 1]));
        end;
      end;
      }
    end;

    If GameHasOneHuman(P) and KillWP then begin
      if PathCostTotal > 0 then begin
        if KillValue + 5 < PathCostTotal + PArmiesCount(WP) then begin
          KillWP:= False;
          m2('KillWP = false, gamehasonehuman, pathcosttotal > 0');
        end;
      end else begin
        if KillValue + 5 < PArmiesCount(WP) then begin
          KillWP:= False;
          m2('KillWP = false, gamehasonehuman, pathcosttotal = 0');
        end;
      end;
    end;

    if KillWP then begin
      if PArmiesCount(PMe) + TIV - PArmiesCount(WP) - PTerritoriesCount(WP) - PathCostTotal < 20 then begin
        m2('dont go below 20, killwp = false');
        KillWP:= False;
      end;
      if KillWP then begin
        MaxTIV:= 0;
        For P:= 1 to 10 do begin
          if PAlive(P) and (P <> PMe) and (PCardTurnInValue(P) > MaxTIV) then MaxTIV:= PCardTurnInValue(P);
        end;
        if PArmiesCount(PMe) - PTerritoriesCount(PMe) + TIV - PArmiesCount(WP) - PTerritoriesCount(WP) - PathCostTotal < MaxTIV then begin
          m2('dont go below MaxTIV, killwp = false');
          KillWP:= False;
        end;
      end;
    end;
  end;

  if (PArmiesCount(PMe) + PNewArmies(PMe) - PTerritoriesCount(PMe) > PArmiesCount(WP) + PTerritoriesCount(WP) + 5) then begin

    if (SAlivePlayersCount = 4) and (PCardCount(Pme) + PCardCount(WP) >= 5) then begin
      cRankSort(rank, parmies, myarmies);
      For x:= 1 to saliveplayerscount do l('Rank ' + i(x) + ': ' + PName(Rank[x]) + ' Armies: ' + i(PArmies[x]));

      MyArmies:= PArmiesCount(PMe) + PNewArmies(PMe) - (PArmiesCount(WP) + PTerritoriesCount(WP) + 5)
       + trunc(double(PCardCount(PMe) + PCardCount(WP))/3 * double(TIV));
      x:= 0;
      For P:= 1 to 10 do Rank[P]:= 0;
      For P:= 1 to 10 do begin
        if (PArmiesCount(P) > 0) and (not (P = WP)) then begin
          x:= x + 1;
          Rank[x]:= P;
          PArmies[x]:= PArmiesCount(Rank[x]) + trunc(double(PCardCount(Rank[x]))/3 * double(PCardTurnInValue(Rank[x])));
        end;
      end;
      APC:= SAlivePlayersCount - 1;
      For x:= 1 to APC - 1 do begin
        For x1:= x + 1 to APC do begin
          if Rank[x1] = PMe then PArmiesX1:= MyArmies else PArmiesX1:= PArmies[x1];
          if Rank[x] = PMe then PArmiesX:= MyArmies else PArmiesX:= PArmies[x];
          if PArmiesX1 > PArmiesX then begin
            temp:= Rank[x];
            Rank[x]:= Rank[x1];
            Rank[x1]:= temp;
            temp:= PArmies[x];
            PArmies[x]:= PArmiesX1;
            PArmies[x1]:= temp;
          end;
        end;
      end;
      for x:= 1 to APC do begin
        if Rank[x] <> PME then l('Rank ' + i(x) + ': ' + PName(Rank[x]) + ' Armies: ' + i(PArmies[x]));
        if Rank[x] = PME then l('Rank ' + i(x) + ': ' + PName(Rank[x]) + ' Armies: ' + i(MyArmies));
      end;
      //m2('check ranks');

      if Rank[1] = PMe then KillWP:= True;
      if (Rank[2] = PMe) and (MyArmies > trunc(0.75 * double(PArmies[1]))) then KillWP:= True;
      //if (Rank[3] = PMe) and (PArmies[2] > trunc(0.9 * double(PArmies[1]))) and (PArmies[3] > trunc(0.5 * double(PArmies[1]))) then KillWP:=True;
    end;

    if SAlivePlayersCount = 3 then begin
      For P:= 1 to 3 do if (Rank[P] <> PMe) and (Rank[P] <> WP) then OP:= Rank[P];
      l('OP: ' + PProgram(OP));
      If (pos('09', lowercase(PProgram(OP))) > 0) then TM:= 0.9 else TM:= 1.05;
      l('my total: ' + i(PArmiesCount(PME) - PTerritoriesCount(PMe) - ( PArmiesCount(WP) + PTerritoriesCount(WP) )
       + trunc( double( PCardCount(Pme) + PCardCount(WP) + 1 )/3 * double(TIV) )));
      l('OPs total: ' + i(trunc( TM * double( PArmiesCount(OP) + trunc( double( PCardCount(OP) )/3 * double(PCardTurnInValue(OP)) ) ) )));
      if ( PArmiesCount(PME) + PNewArmies(PMe) - PTerritoriesCount(PMe) - ( PArmiesCount(WP) + PTerritoriesCount(WP) )
       + trunc( double( PCardCount(Pme) + PCardCount(WP) + 1 )/3 * double(TIV) )
       >  trunc( TM * double( PArmiesCount(OP) + trunc( double( PCardCount(OP) )/3 * double(PCardTurnInValue(OP)) ) ) ) ) and (PCardCount(OP) < 3)
      then begin
        KillWP:= True;
        if m2('1 SAPC = 3 killwp ' + pprogram(WP)) then exit;
      end else begin
        if (PCardCount(Pme) + PCardCount(WP) >= 5) and (PArmiesCount(WP) + PTerritoriesCount(WP) < (PArmiesCount(PMe) + PNewArmies(PMe) - PTerritoriesCount(PMe)) div 10) then begin
          KillWP:= True;
          if m2('2 SAPC = 3 killwp ' + pprogram(WP)) then exit;
        end;
      end;
    end;

  end;
end;


procedure Assignment(var ToTerritory: integer);
var
  T: integer;
begin
  // find the first free territory
  ToTerritory:= 0;
  T:= 1;
  repeat
    if TOwner(T)= 0 then
      ToTerritory:= T;
    T:= T + 1;
  until (ToTerritory > 0) or (T > 42);
end;

{-------------------------------Placement---------------------------------------------------------------}

procedure Placement(var ToTerritory: integer);
var
  Extra2, Extra, BT1,  Total, B, C, BT, Y, CTArmies, Ts, MostFronts, TWF, WF,
  T1, WP, Enough, TT, iNode, iChild, PL, Count, MaxC, WFA, CForce, x, T, ET,
  iChild1, oMaxArmy, MinCost, Armies, TotalNeeded, TotalCost, PlaceTCount, PAC, EAC,
  TTNeeds1, PathCostTotal, MaxArmyWillUse, MaxArmy1, MinEA, PathCost, MaxArmy, EA, Cost: integer;

  EA1, Rank, Army: array of integer;
  HasEnough: array of boolean;
  AddTemp: array [1..42] of boolean;
  TCanTake: array [1..42] of integer;

  TCis2, KillWP, Abort, IncreaseExtra, go: boolean;

  aNode: array [1..42] of record
    bClosed: boolean;
    bOpen: boolean;
    bTotalEA: integer;
    PathCost: integer;
    Parent: integer;
  end;
  bNode: array [1..42] of record
    Closed: boolean;
    Open: boolean;
  end;

begin
  if bg(152) = 0 then utakesnapshot('begin placement');
  bs(152, 1);
  //m2('pl pause');
  bs(88, 0);
  bs(87, 0);

  ToTerritory:=0;
  ArmySort(Army);
  ConquestForce(CForce);

  if PNewArmies(Pme) = 1 then begin
    bs(57, 1);
  end else bs(57, 0);

  if bg(300) = 1 then begin
    x:= 300;
    Repeat
      x:= x + 1;
      if bg(x) > 0 then begin
        ToTerritory:= x - 300;
        bs(x, bg(x) - 1);
        if bg(x) = 0 then bs(x, -1);
        m2('place to ' + i(toterritory) + 'new bgx ' + i(bg(x)));
      end;
      if bg(x) < -100 then begin
        ToTerritory:= x - 300;
        bs(x, bg(x) + 1);
        m('TCis2, place to ' + i(toterritory) + 'new bgx ' + i(bg(x)));
      end;
    Until (ToTerritory > 0) or (x = 342);
    if PNewArmies(PMe) = 1 then bs(300, 0);
    if (ToTerritory = 0) and (PNewArmies(PMe) > 1) then bs(300, 2);
    if PNewArmies(PMe) = 1 then bs(300, 0);
    if ToTerritory > 0 then exit;
  end;
  if bg(300) = 2 then begin
    //m2('begin extra part');
    y:= 0;
    Repeat
      x:= 300;
      y:= y - 1;
      Repeat
        x:= x + 1;
        if bg(x) = y then begin
          ToTerritory:= x - 300;
          if m2('place an extra on ' + i(x-300) + ', bgX ' + i(bg(x))) then exit;
          bs(x, bg(x) - 1);
        end;
      Until (ToTerritory > 0) or (x = 342);
      if (y = -3) and (ToTerritory = 0) then begin
        x:= 300;
        Repeat
          x:= x + 1;
          if (bg(x) = -100) then begin
            ToTerritory:= x - 300;
            bs(x, bg(x) + 1);
            if m2('place an extra extra on ' + i(x-300) + ', bgX ' + i(bg(x))) then exit;
          end;
        Until (ToTerritory > 0) or (x = 342);
      end;
    Until (ToTerritory > 0) or (y = -3);
    if (ToTerritory = 0) or (PNewArmies(PMe) = 1) then bs(300, 0);
    if ToTerritory > 0 then exit;
  end;

  if (bg(52) > 0) and (TOwner(bg(52)) <> PMe) then begin
    UTakeSnapshot('i dont own buffer 52');
    m2(' i dont own buffer 52');
  end;
  if (bg(52) > 0) and (TOwner(bg(52)) = PMe) then begin
    m2('bg52 ' + i(bg(52)) + ' bg 151 ' + i(bg(151)) + ' bg58 ' + i(bg(58)) + ' bg56 ' + i(bg(56)));
    if (TArmies(bg(52)) < bg(58)) or (bg(56) > 11) then begin // for kill last player placement
      ToTerritory:= bg(52);
      if bg(151) = 1 then begin
        bs(151, 0);
        bs(52, 0);
      end;
      if bg(151) > 0 then bs(151, bg(151) - 1);
      if PNewArmies(PMe) = 1 then begin
        bs(52, 0);
        if bg(151) > 0 then m2('place to kill player error, bg151: ' + i(bg(151)));
        bs(151, 0);
        bs(56, 0);
        bs(58, 0);
      end;
    end else bs(52, 0);
    if ToTerritory > 0 then exit;
  end;

  //UTakeSnapshot(' kill last player placement ');
{----------------------------Kill Last Player Placement-------------------------------------------------------}
  KillBoth:= False;                                                  // in case the placement proc determined that I can't kill the WP
  if (SAlivePlayersCount = 3) then begin
    PAC:= 0;
    EAC:= 0;
    For T:= 1 to 42 do begin
      if TIsFront(T) and (TArmies(T) > 1) then PAC:= PAC + TArmies(T) - 1;
      if TOwner(T) <> PMe then EAC:= EAC + TArmies(T) + 1;
    end;
    if PAC + PNewArmies(PMe) > EAC + 10 then begin
      m2('Place to kill both');
      KillBoth:= True;
    end;
  end;
  If (SAlivePlayersCount = 2) or KillBoth or (bg(64) = 100) then begin
    //if (bg(52) > 0) and ( (TArmies(bg(52)) < bg(58)) or (bg(56) > 11) ) and (TOwner(bg(52)) = PMe) then ToTerritory:= bg(52) else begin
    bs(52, 0);
    Extra2:= bg(56);
    ArmySort(Army);
    setarraylength(HasEnough, 43);
    for x:= 1 to 42 do HasEnough[x]:= False;
    //a:= 0;
    Repeat
      MaxC:= 0;
      IncreaseExtra:= True;
      //a:= a + 1;
      for Y:= 1 to PTC do begin
      //m('Army[Y] ' + i(Army[Y]));
      //m('cforce ' + i(Cforce));
        If TIsFront(Army[y]) then begin
          go:= True;
          if Y > 1 then for x:= Y-1 downto 1 do
           if HasEnough[Army[x]] then if TsAreConnected(0, Army[y], Army[x]) then go:= False;

          if go then begin
            Total:= 0;
            For B:= 1 to TFrontsCount(Army[y]) do begin
              BT:= TFront(Army[y], B);
              go:= True;
              if B > 1 then for x:= B-1 downto 1 do begin
                BT1:= TFront(Army[y], x);
                if TsAreConnected(0, BT, BT1) then go:= False;
              end;
              If go then begin
                AddConnectedTsArmies(Army[y], BT, CTArmies, Ts);
                Total:= Total + CTArmies; // CTArmies now includes the value Ts
              end;
            end;
            Extra:= Ts div 3;
            if Extra < 2 then Extra:= 2;
            enough:= Total + Extra + Extra2;
            if TArmies(Army[y]) < enough then begin
              IncreaseExtra:= False;
              TStrongestFront(Army[y], ET , EA);
              if (EA < CForce) and (not (TArmies(Army[y]) = 1)) then begin
                ToTerritory:= Army[y];
                bs(52, ToTerritory);
                bs(58, Enough);
                m('EA < Cforce, TT: ' + i(ToTerritory));
                exit;
              end else begin
                // place on the T with the best chance to take as many T's as possible
                C:= 0;
                For T:= 1 to 42 do begin
                  if (not TIsMine(T)) then begin
                    if (TArmies(T) < CForce) then begin
                      if QTWeakestPath(Army[y], T, 0, TT, PL, EA) then begin
                        if EA < CForce then C:= C + 1;
                      end;
                    end;
                  end;
                end;
                if (C > MaxC) then begin
                  MaxC:= C;
                  ToTerritory:= Army[y];
                  bs(52, ToTerritory);
                  bs(58, Enough);
                  m('MAxC, TT: ' + i(ToTerritory));
                end;
              end;
            end else begin
              HasEnough[Army[y]]:= True;
            end;
          end;
        end;
      end;
      If ToTerritory = 0 then begin
        TWithWeakestFront(TWF, WF, WFA);
        if CForce < WFA then CForce:= WFA + 1 else
         CForce:= ((CForce * 12) div 10) + 1;
        if IncreaseExtra then Extra2:= Extra2 + 4;
        bs(56, Extra2);
      end;
    Until (ToTerritory > 0);// or ( a = 5);
    //end;
    if Extra2 >= 12 then bs(52, ToTerritory);
    if PNewArmies(PMe) = 1 then begin
      bs(52, 0);
      bs(56, 0);
      bs(58, 0);
    end;
    //l('Last Player Placement, ToTerritory: ' + i(ToTerritory) + ' PNewArmies ' + i(PNewArmies(PMe)));
    exit;
  end;

{--------------------------Place to help kill a player-----------------------------------------------------}
  //if bg(59) = 0 then UTakeSnapshot('begin placement');
  if (bg(59) = 0) and (PTerritoriesCount(PMe) > 1) then begin
    bs(89, 0);
    RankSort(Rank);
    Extra:= bg(56);

    if (Rank[SAlivePlayersCount] <> PMe) then begin
      WP:= Rank[SAlivePlayersCount];
      PathCostTotal:= 0;
      KillWeakPlayerCheck(WP, PathCostTotal, KillWP, Rank);
 //    killwp:= true;
      If KillWP then begin
       // UTakeSnapshot('place to help kill a player');
         For x:= 300 to 342 do bs(x, 0);
      l('killwp = true, max that combined pathcosts can be: ' + i((PArmiesCount(PME) +  PNewArmies(PMe) - PTerritoriesCount(PMe)) - (PArmiesCount(WP) + PTerritoriesCount(WP))));

        Abort:= False;
        for T:= 1 to 42 do begin
          AccountedFor[T]:= false;
          TCanTake[T]:= 0;
          TTNeeds[T]:= 0;
        end;
        PlaceTCount:= 0;
        TotalNeeded:= 0;

        MaxArmy:= Army[1];
        Repeat
          l('MaxArmy ' + i(MaxArmy));
          aNode[MaxArmy].bTotalEA:= 0;

          for T:= 1 to 42 do begin
            with aNode[T] do begin
              bClosed := false;
              bOpen:= false;
              PathCost:= 0;
              Parent:= 0;
            end;
            AddTemp[T]:= false
          end;

          aNode[MaxArmy].bopen := True;

          Repeat
            T1:= 0;
            iNode:= 0;
            repeat
              T1:= T1 + 1;
              if aNode[T1].bopen and not aNode[T1].bClosed then begin
                iNode:= T1;
              end;
            until (iNode > 0) or (T1 = 42);

        //    m2('iNode ' + i(inode));
            if iNode <> 0 then begin
              for B:= 1 to TBordersCount(iNode) do begin
                iChild:= TBorder(iNode, B);
                if iChild = MaxArmy then continue;

         //       if m2('before, inode ' + i(inode) + ' inode pathcost ' + i(anode[inode].pathcost) + ' ichild ' + i(ichild) + ' pathcost ' + i(anode[ichild].pathcost)) then exit;
                if (TOwner(iChild) <> PMe) then begin
                  if (TOwner(iChild) <> WP) then PathCost:= aNode[iNode].PathCost + TArmies(iChild) + 1 else
                   PathCost:= aNode[iNode].PathCost;
                  if (not aNode[iChild].bOpen) or (PathCost < aNode[iChild].PathCost)
                   or ((PathCost = aNode[iChild].PathCost) and (TOwner(aNode[iChild].Parent) <> WP)
                   and (TOwner(iNode) = WP) {and (TOwner(iChild) <> PMe)} and (aNode[iChild].Parent <> MaxArmy)
                   and (aNode[iNode].parent <> iChild)) then begin
                    //if m2('inode ' + i(inode) + ' ichild ' + i(ichild) + ' pathcost ' + i(pathcost) + ' ichild parent: ' + i(anode[ichild].parent)) then exit;
           //         l('inode ' + i(inode) + ' ichild ' + i(ichild) + ' pathcost ' + i(pathcost) + ' ichild parent: ' + i(anode[ichild].parent));

                    aNode[iChild].Parent:= iNode;
                    aNode[iChild].PathCost:= PathCost;
                    aNode[iChild].bClosed:= false;
                    //if m2('un-close ' + i(ichild)) then exit;
                  end;

                end;
           //     if m2('after, inode ' + i(inode) + ' ichild ' + i(ichild) + ' pathcost ' + i(anode[ichild].pathcost) + ' ichild parent: ' + i(anode[ichild].parent)) then exit;
                if aNode[iChild].PathCost <=          // do not include the value totalneeded here
                (PArmiesCount(PME) +  PNewArmies(PMe) - PathCostTotal - PTerritoriesCount(PMe)) - (PArmiesCount(WP) + PTerritoriesCount(WP)) then begin
                  if TOwner(iChild) <> PMe then begin
                    if (not aNode[iChild].bOpen) and (not aNode[iChild].bClosed) and (not AccountedFor[iChild]) then begin
                      aNode[iChild].bOpen:= true;
                      aNode[MaxArmy].bTotalEA:= aNode[MaxArmy].bTotalEA + TArmies(iChild) + 1;
                      if TOwner(iChild) = WP then AccountedFor[iChild]:= True;
                    end;
                  end;
                end;
              end;
              aNode[iNode].bClosed := true;
            end;
          until (iNode = 0);

          //if m2('3 start new part, T ' + i(MaxArmy)) then exit;
          Repeat
            For iChild:= 1 to 42 do begin
              if aNode[iChild].bOpen and (TOwner(iChild) = WP) then begin
              //  l('ichild ' + i(ichild) + ' pathcost ' + i(anode[ichild].pathcost));
                if aNode[iChild].PathCost > ( (PArmiesCount(PME) +  PNewArmies(PMe) - PTerritoriesCount(PMe))
                 - (PArmiesCount(WP) + PTerritoriesCount(WP)) ) div 2 then begin
                  l('1, ichild ' + i(ichild));
                  if PlaceToKillPlayer2(WP, iChild, PathCostTotal, Cost, MaxArmy1) then begin
                    l('2, ichild ' + i(ichild) + ' cost ' + i(cost) + ' PathCost ' + i(anode[ichild].pathcost) + ' maxarmy1 ' + i(maxarmy1) + ' maxarmy ' + i(maxarmy));
                    if (MaxArmy1 <> MaxArmy) then begin
                      aNode[iChild].bOpen:= false;
                      AccountedFor[iChild]:= false;
                      l('3, ichild removed, ' + i(ichild));

                      // removed any of WP's Ts that are connected
                      for T:=1 to 42 do begin
                        with bNode[T] do begin
                          Closed := false;
                          Open:= false;
                        end;
                      end;

                      bNode[iChild].open := True;
                      Repeat
                        T:= 0;
                        iNode:= 0;
                        repeat
                          T:= T + 1;
                          if bNode[T].Open and not bNode[T].Closed then begin
                            iNode:= T;
                          end;
                        until (iNode > 0) or (T = 42);

                        if iNode <> 0 then begin
                          for B:= 1 to TBordersCount(iNode) do begin
                            iChild1:= TBorder(iNode, B);
                            if TOwner(iChild1) <> WP then Continue;

                            if ((not bNode[iChild1].Open) and (not bNode[iChild1].Closed)) then begin
                              l('4, ichild1 removed, ' + i(ichild1));
                              aNode[iChild1].bOpen:= false;
                              AccountedFor[iChild1]:= false;
                              bNode[iChild1].Open:= true;
                            end;
                          end;
                          bNode[iNode].Closed := true;
                        end;

                      until (iNode = 0);

                      Break;
                    end;
                  end;
                end;
              end;
            end;
          Until iChild = 43;

          For x:= 1 to 42 do AddTemp[x]:= false;
          For x:= 1 to 42 do begin
            if aNode[x].bOpen and (TOwner(x) = WP) then begin
              AddTemp[x]:= True;
              iNode:= x;
              while (aNode[iNode].Parent > 0) do begin
                AddTemp[iNode]:= True;
          //      if m2('inode ' + i(inode) + ' parent ' + i(aNode[iNode].parent)) then exit;
                //l('inode ' + i(inode) + ' parent ' + i(aNode[iNode].parent));
                iNode := aNode[iNode].Parent;
              end;
            end;
          end;

          TotalCost:= 0;
          ET:= 0;
          For x:= 1 to 42 do begin
            if AddTemp[x] then begin
              TotalCost:= TotalCost + TArmies(x) + 1;
              if TOwner(x) <> WP then PathCostTotal:= PathCostTotal + TArmies(x);
              ET:= ET + 1;  // have to count ET here, not above because .parent = 0 whenever you get to the first WP ET that is connected to ST
            end;
          end;
          TCis2:= False;
          if TotalCost = 2 then begin
            TCis2:= True;
            TotalCost:= 3;
          end else TotalCost:= TotalCost + 3 + (ET div 3) + extra;
          //if m2('total cost: ' + i(Totalcost)) then exit;
          l('total cost: ' + i(Totalcost));

           //if m2('4 start new part, T ' + i(MaxArmy)) then exit;
          TCanTake[MaxArmy]:= aNode[MaxArmy].bTotalEA - (TArmies(MaxArmy) - 1);
          if TotalCost > (TArmies(MaxArmy) - 1) + PNewArmies(PMe) then abort:= true else begin
            TTNeeds[MaxArmy]:= TotalCost;
            if TotalCost > (TArmies(MaxArmy) - 1) then begin
              PlaceTCount:= PlaceTCount + 1;
              ToTerritory:= MaxArmy;
              bs(300, 1);
              if TCis2 then bs(300 + MaxArmy, -103) else bs(300 + MaxArmy, TotalCost - (TArmies(MaxArmy) - 1));
           //   m3('bg 300 + maxarmy: ' + i(bg(300+maxarmy)));
              TotalNeeded:= TotalNeeded + TotalCost - (TArmies(MaxArmy) - 1);
            end;
          end;
          //if m2('5 start new part, T ' + i(MaxArmy)) then exit;
          // find a new T that might need more armies

          if abort then l('abort, TotalCost > (TArmies(MaxArmy) - 1) + PNewArmies(PMe)') else begin
            if TotalNeeded > PNewArmies(PMe) then begin
              abort:= true;
              l('abort, TotalNeeded > PNewArmies');
            end;
          end;

          oMaxArmy:= MaxArmy;
          MaxArmy:= 0;
          C:= 0;
          T:= 0;
          if not abort then begin
            MinCost:= 0;
            Repeat
              T:= T + 1;
              if (TOwner(T) = WP) and (not AccountedFor[T]) then begin
                C:= C + 1;
                l('find next maxarmy, T ' + i(t));
                if PlaceToKillPlayer2(WP, T, PathCostTotal, Cost, MaxArmy1) then begin
                  if ((Cost < MinCost) or (MinCost = 0)) and (not (MaxArmy1 = oMaxArmy)) then begin
                    MinCost:= Cost;
                    MaxArmy:= MaxArmy1;
                    m2('find next maxarmy, MaxArmy: ' + i(maxarmy) + ' cost ' + i(cost));
                  end;
                end;
              end;
              //if m2('end of repeat2, T ' + i(T) + ' maxarmy ' + i(maxArmy)) then exit;
            Until (MaxArmy > 0) or (T = 42);
          end;
          if (MaxArmy = 0) and (C > 0) then begin
            Abort:= True;
            bs(89, WP); // tell the attack proc that i can't kill WP until i get more armies to place
            m2('bs89, cant find then next maxArmy');
          end;
         // if m2('end of repeat3') then exit;
        //if abort then l('maxarmy ' + i(maxarmy) + ' abort ');
        Until (MaxArmy = 0) or abort;
      end; // end If KillWP
    end;
    l('************* total needed ' + i(totalneeded) + ' place T count ' + i(PlaceTCount));
    if ((PNewArmies(PMe) < TotalNeeded) and (PNewArmies(PMe) > 1)) or Abort then begin
      ToTerritory:= 0;
      bs(300, 0);
      l('cancel place to kill player, dont have enough armies, total needed: ' + i(totalneeded) + ' or abort=true');
    end;
    //if (ToTerritory > 0) and (PNewArmies(PMe) - TotalNeeded > 0) and (PlaceTCount = 1) then begin
    //  bs(56, bg(56) + 1);
    //end;
    if ToTerritory > 0 then begin
      m2('pathcostTotal ' + i(PathCostTotal));
      KillWeakPlayerCheck(WP, PathCostTotal, KillWP, Rank);
      if not KillWP then begin
        ToTerritory:= 0;
        bs(300, 0);
        bs(89, WP);
        m2('cancel place to kill player, pathcost too high, set buffer 89');
      end;
    end;

    PathCostTotal:= 0;
    if ToTerritory > 0 then begin
      bs(ToTerritory + 300, bg(ToTerritory + 300) - 1);
      //if TTNeeds[ToTerritory] - (TArmies(ToTerritory) - 1) > 1 then begin
      //  bs(52, ToTerritory);
      //  bs(151, TTNeeds[ToTerritory] - (TArmies(ToTerritory) - 1) - 1); // subtract an additional army to account for the one being placed with this call
      //end;
      m2('kill player placement, TT: ' + i(ToTerritory) + ', total needed: ' + i(TotalNeeded) + ', extra: ' + i(extra) + ', PNewArmies: ' + i(PNewArmies(PMe)));
      //if PNewArmies(PMe) = 1 then bs(56, 0);
      //if bg(56) > 3 then bs(56, 0);
      exit;
    end;
    //m2('blasphemy');
    if SAlivePlayersCount = 3 then begin
      if AddConnectedArmies(0, Army[1], Armies, Ts) then begin
        if Armies + Ts + 5 < TArmies(Army[1]) - 1 then begin
          For T:= 1 to 42 do begin
            if (TCanTake[T] > 0) and (T <> Army[1]) then begin
              ToTerritory:= T;
              if TCanTake[T] - 1 >= PNewArmies(PMe) - 1 then bs(151, PNewArmies(PMe) - 1) else bs(151, TCanTake[T] - 1);
              if bg(151) > 0 then bs(52, ToTerritory);
              bs(59, 0); // run the code again in case there are more T that can take armies
              m2('army1 has enough, place to : ' + i(toterritory));
              exit;
            end;
          end;
        end;
      end;
    end;
    bs(59, 1); // don't run this code again
  end;
  if PNewArmies(PMe) = 1 then bs(59, 0);

{--------------------------Regular Placement---------------------------------------------------------------}

  if  not SCardsBasedOnCombo then begin
    if (bg(53) = 0) or (bg(53) <> TIV) then begin
      bs(55, TIV-bg(53)); // stores the change in CTIV
      bs(53, TIV);  // stores my card turn in value
      bs(54, 1);    // 1 means cards have been turned in this turn (not currently used)
    end;
  end;

  //ConquestForce(CForce);
  TWithWeakestFront(TWF, WF, WFA);
 // RankSort(Rank);

  // If can't make a good attack then try placing somewhere that can attack
  If not SCardsBasedOnCombo and (WFA < CForce) and (bg(51) = 1) then begin
    Count:= 0;
    //SetArrayLength(ET1, PTC + 1);
    SetArrayLength(EA1, PTC + 1);
    For x:= 1 to PTC do begin
      TWeakestFront(Army[x], ET, EA1[x]);
      if (ET > 0) and (EA1[x] <= CForce) and ( (TArmies(Army[x]) >= EA1[x] + 5) or ((EA1[x] = 1) and (TArmies(Army[x]) >= 4)) ) then count:= count + 1;
    end;
    if count = 0 then begin
      MinEA:= 0;
      For x:= 1 to PTC do begin
        if EA1[x] > 0 then begin
          if (TArmies(Army[x]) + PNewArmies(PMe) > EA1[x] + 2) and (EA1[x] < CForce) and ( (EA1[x] < MinEA) or (MinEA = 0) ) then begin
            MinEA:= EA1[x];
            ToTerritory:= Army[x];
          end;
        end;
      end;
      if (ToTerritory > 0) and (PNewArmies(PMe) > 1) then begin
        if (MinEA = 1) and (TArmies(ToTerritory) < 4) then begin
          TTNeeds1:= 3 - TArmies(ToTerritory);
          if TTNeeds1 > 0 then begin
            bs(52, ToTerritory);
            bs(151, TTNeeds1);
          end;
        end;
        if (MinEA > 1) then begin
          TTNeeds1:= (4 + MinEA) - TArmies(ToTerritory);
          if TTNeeds1 < PNewArmies(PMe) - 1 then begin
            if TTNeeds1 < 0 then TTNeeds1:= 0;
            bs(151, TTNeeds1);
          end;
          if TTNeeds1 > 0 then bs(52, ToTerritory);
        end;
        m2('place to get card, TT ' + i(ToTerritory) + ', buffer 151: ' + i(bg(151)));
        exit;
      end;
    end;
  end;

  if ToTerritory = 0 then begin
    if (not TIsFront(Army[1])) and (PArmiesCount(PMe) > 20) then begin
      x:= 1;
      Repeat
        x:= x + 1;
        if TIsFront(Army[x]) then ToTerritory:= Army[x];
      Until ToTerritory > 0;

    end else ToTerritory:= Army[1];
    {
    if GameHasNoHumans then begin
      if (PArmiesCount(Pme) > 50) then begin
        x:= PTC;
        Repeat
          if TArmies(Army[x]) > 5 then begin
            if not ( (COwner(6) = PMe) and (TContinent(Army[x]) = 6) ) then
             ToTerritory:= Army[x];
            //bs(52, ToTerritory);
          end;
          x:= x - 1;
        until (ToTerritory > 0) or (x = 0);
      end else begin
        ToTerritory:= Army[1];
        //bs(52, ToTerritory);
      end;
    end else begin
      if TArmies(Army[2]) > 5 then ToTerritory:= Army[2] else ToTerritory:= Army[1];
    end;
    }
  end;

  if ToTerritory = 0 then begin
    ToTerritory:= TWF;
    if PNewArmies(PMe) = 1 then m('backup twf place ' + inttostr(ToTerritory));

    //bs(52, ToTerritory);
  end;

  {-----------Code for first turn only-----------}
  if bg(51) = 0 then begin
    MostFronts:= 0;
    for T:=1 to 42 do begin
      if TIsFront(T) then begin
        if TFrontsCount(T) > MostFronts then begin
          ToTerritory:=T;
          MostFronts:=TFrontsCount(T);
          bs(52, T);
        end;
      end;
    end;
    bs(51, 1);
    bs(81, 1);
    //umessage('first turn');
  end;

  if PNewArmies(PMe) = 1 then begin
    bs(52, 0);
    bs(54, 0); // reset to 0 means cards haven't been turned in this turn
  end;
end; // end procedure Placement

{------------------------------------------ATTACK--------------------------------------------------------}

procedure Attack(var FromTerritory, ToTerritory: integer);
var
  EA1, SP, WP, P, E, MinArmy, MaxArmy, B, BT, PL, x, Cost, TT, T, ET, EA, MaxCost,
  C, MinCost, TWF, WF, Y, Armies, WPArmies, NewPArmiesCount, CForce, MaxPArmiesCount,
  TotalEnemyArmies, Separated, T1, PT, PA, Z, FT, FirstFT, FirstTT, OldMaxCost,
  Subtract, WFA, APC, MyArmies, OP, total, x1, PArmiesX1, PArmiesX, temp,
  KillValue, a, bgb, bgb1, bga, LastTT, start, finish, MaxTIV, Extra,
  oMinArmy, C1, TT2, WFA1, B1, B2, BT2, BT1, QMyAC, QMyTC, Diff, PAC: integer;

  go, Weaken, KillAll, Abort, Human, AttackSP, ATC, KillWP: Boolean;
  Coef, aPoints, TM, OldMaxPoints, MaxPoints: Double;
  qmap: String;
  
  ReOrder, Rank, Army, PArmies: Array of integer;
  //Points: double;
  Points: array of double;
  SPEntryT: array of boolean;

begin
  bs(152, 0);
  //  if not sconquest then if (Not gamehasonehuman(P)) then UAbortGame;
  SetArrayLength(Points, 43);
  Weaken1:= False;
  if ( (TOwner(bg(68)) = PMe) or (TOwner(bg(100)) = PMe) ) and (bg(70) = 0) then begin
    m('occupation routine not called after a stored attack');
    bs(73, 0);
    bs(74, 0);
    bs(68, 0);
    bs(69, 0);
    bs(60, 0); // reset attack determined by attack strong player code
    bs(100, 0);
    bs(101, 0);
  end;
  bs(70, 0);

  bs(67, 0); // reset stored occupy amount
  //bs(90, 0); // reset attack determined by continents code
  bs(92, 0); // reset pottential occupation ToTerritory


  if (not (TOwner(bg(91))) = PMe) then bs(91, 0); // reset the last T I occupied in case occupation routine not called again
  FromTerritory:=0;
  ToTerritory:=0;

  // Attack until i run out of armies or TArmies(ToTerritory < 3)
  if bg(98) > 0 then begin
    if bg(98) > 100 then TT:= bg(98) - 100 else TT:= bg(98);
    if bg(99) > 100 then FT:= bg(99) - 100 else FT:= bg(99);
    if (TArmies(TT) > 2) and (TArmies(FT) > 2) and (TOwner(FT) = PMe) and (TOwner(TT) <> PMe) then begin
      ToTerritory:= TT;
      FromTerritory:= FT;
      if bg(85) > 0 then begin
        bs(85, bg(85) - 1);
        //l('bg85 ' + i(bg(85)));
        if bg(85) = 0 then begin
          m2('2 Done weakening player, TT: ' + i(bg(98)));
          bs(98, 0);
          bs(98, 0);
          bs(85, 0);
        end;
      end;
      exit;
    end else begin
      m2('1 Done weakening TT ' + i(bg(98)));
      bs(85, 0);
      bs(98, 0);
      bs(99, 0);
      bs(68, 0);
      bs(69, 0); //just in case these were set with the same values on accident
    //  ResetBuffers;
    end;
  end;

  // Repeat the last attack (speeds up performance)
  if (bg(68) > 0) then begin
    if (not ( (TArmies(bg(69)) < 4) and (TArmies(bg(68)) > 1) ))
     and (TArmies(bg(69)) > 1) and (TOwner(bg(69)) = PMe) and (TOwner(bg(68)) <> PMe) then begin
      if (TArmies(bg(69)) < TArmies(bg(68)) - 5) and (SAlivePlayersCount > 2) then begin
        m2('not winning this battle, abort stored attack');
        ResetBuffers;
      end else begin
        ToTerritory:= bg(68);               // ^ needed because the occ procedure isn't called when you have no armies to occupy with
        FromTerritory:= bg(69);             // for final release add an owner check for the fromT
        exit;
      end;
    end else begin
      if (not(SAlivePlayersCount = 2)) then begin
        if TOwner(bg(68)) = PMe then m2('bg(68), I own the TT');
        if (TArmies(bg(69)) < 4) and (TArmies(bg(68)) > 1) then m2('ran out of armies, FT: ' + i(bg(69)));
      end;
      ResetBuffers;
    end;
  end;

 // l('begin attack');
  // Follow the stored Kill Player path
  // if I get lucky rolls then sometimes I kill a player even before the path is done so reset if WP is dead (only happens if I have two separate large armies)
  if (PArmiesCount(bg(63)) = 0) and (bg(400) = 1) then begin
    m('he is already dead');
    bs(400, 0);
    bs(401, 0);
    bs(63, 0);
  end;
  if bg(400) = 1 then begin
    x:= 402;
    Repeat
      x:= x + 2
      if bg(x) > 0 then begin
          m('new code');
        FromTerritory:= bg(x);
        bs(x, 0);
        ToTerritory:= bg(x+1);
        bs(x+1, 0);
       // l('toterritory ' + i(toterritory));
        if ToTerritory > 100 then begin
          FromTerritory:= FromTerritory - 100;
          ToTerritory:= ToTerritory - 100;
          if (TArmies(ToTerritory) > 2) and (TArmies(FromTerritory) > 2) then begin
            //m2('test ');
            bs(99, FromTerritory);
            bs(98, ToTerritory);
            exit;
          end else begin
            m2('buffer 98,99 problem, ft ' + i(FromTerritory) + ' TT ' + i(ToTerritory) + ' x ' + i(x));
            FromTerritory:= 0;
            ToTerritory:= 0;
          end;
        end;

      end;
    Until (FromTerritory > 0) or (x = bg(401));
    if (FromTerritory > 0) then begin
      //if fromterritory = 2 then if m2('pause ft = 2') then exit;

      if //( (TArmies(FromTerritory) < TArmies(ToTerritory)) and (TArmies(ToTerritory) < 15) )
       //or
       ( (TArmies(FromTerritory) < 4) and (TArmies(ToTerritory) > 1) )
       or (TArmies(FromTerritory) = 1)
       or (not TIsMine(FromTerritory)) or TIsMine(ToTerritory) then begin


        m2('end kill player3');
        FromTerritory:= 0;
        ToTerritory:= 0;
        ResetBuffers;
      end else begin
        if bg(63) = 0 then m('buffer 63 is 0');

        bs(69, FromTerritory);
        bs(68, ToTerritory);
      end;
    end else begin
      m2('end kill player4');
      ResetBuffers;
    end;
    if x = bg(401) then begin
      //m('**** successful kill? ****');
      bs(400, 0);
      bs(401, 0);
    end;
    if FromTerritory > 0 then begin
      bs(86, TOwner(ToTerritory));
      exit;
    end;
  end;

  bs(64, 0); // reset attack all players (currently only used when alive players = 2)
  //bs(77, 0); // reset BestFT (KillPlayerOcc) - only used if BestFT is not connected to TT or FT
  if bg(400) = 0 then resetBuffers;

  ConquestForce(CForce);
  RankSort(Rank);

  {-----------------------------------Take South America-------------------------------------------------}
{
  if bg(91) > 0 then begin // 91 - the last T I occupied while in take continent mode
    FT:= bg(91);
    if TIsMine(FT) and (TArmies(FT) > 1) then begin
      if (FT = 10) and (not TIsMine(11)) then ToTerritory:= 11;
      if (FT = 10) and TIsMine(11) and (not TIsMine(12)) then ToTerritory:= 12;
      if (FT = 11) and (not TIsMine(13)) then ToTerritory:= 13;
      if (FT = 11) and TIsMine(13) and (not TIsMine(12)) then ToTerritory:= 12;
      if (FT = 12) and (not TIsMine(13)) then ToTerritory:= 13;
      if (FT = 12) and TIsMine(13) and (not TIsMine(11)) then ToTerritory:= 11;
      if (FT = 12) and TIsMine(13) and (not TIsMine(10)) then ToTerritory:= 10;
      if (FT = 13) and TIsMine(12) and (not TIsMine(11)) then ToTerritory:= 11;
      if (FT = 13) and TIsMine(11) and (not TIsMine(12)) then ToTerritory:= 12;
      if ToTerritory > 0 then begin
        FromTerritory:= FT;
        bs(92, ToTerritory); // Tell the occupation proc to set buffer 91 to this value
        bs(90, 1); // tell the occupation proc what code to use
        l('used new SA code');
      end;
    end;
    if TArmies(FT) = 1 then bs(91, 0); // reset the last T I occupied
    if FromTerritory > 0 then exit;
  end;

  C:= 2;
  If (SAlivePlayersCount < 5) and (SAlivePlayersCount > 2) and (CPT(C) = 0) then begin
    Count:= 0;

    For P:= 1 to 10 do begin
      if PAlive(P) then begin
        If (pos('descartes', lowercase(PProgram(P))) > 0) or
         (pos('zotob', lowercase(PProgram(P))) > 0)
         then Count:= Count + 1;
      end;
    end;

    if Count = 0 then begin
      MinCost:= TIV;
      For T:= 1 to 42 do begin
        if TIsFront(T) and (TArmies(T) > TIV) then begin
          if QTWeakestPath(T, 12, TT, PL, EA) and (T <> 12) then begin
            Cost:= EA + PL + CEA(C);
            if ((Cost < MinCost) or (MinCost = 0)) and (Cost < TArmies(T)) then begin
              MinCost:= Cost;
              FromTerritory:= T;
              ToTerritory:= TT;
            end;
          end;
          if QTWeakestPath(T, 10, TT, PL, EA) and (T <> 10) then begin
            Cost:= EA + PL + CEA(C);
            if ((Cost < MinCost) or (MinCost = 0)) and (Cost < TArmies(T)) then begin
              MinCost:= Cost;
              FromTerritory:= T;
              ToTerritory:= TT;
              //if fromterritory = 10 then m('tt ' + i(TT) + ' PL ' + i(pl) + ' ea ' + i(ea));
            end;
          end;
        end;
      end;
    end;
  end;
  If (FromTerritory > 0) and (ToTerritory > 0) then begin
    bs(90, 1);
    if TArmies(ToTerritory) < 3 then l('take SA code ft: ' + i(FromTerritory) + ' TT: ' + i(ToTerritory));
    exit
  end;
}

  If (bg(64) = 100) or (SAlivePlayersCount = 2) then begin
    For P:= 1 to 10 do if (P <> PMe) and PAlive(P) then WP:= P;
    //bs(64, 100);
    bs(63, WP);
    if (bg(73) > 0) then begin // and (TArmies(bg(73)) > 1) and TIsMine(bg(73)) then begin // tarmies can be 1 or 2 when occupation routine is not called because the fromterritory has no armies with which to occupy
      FromTerritory:= bg(73);
      //KillPlayerAttack2(bg(74), FT, TT);
      //if TT = 0 then FT:= 0;
      ToTerritory:= bg(74);
      if FromTerritory > 0 then m('1 buffer 73 code, FT: ' + i(FT) + ' TT: ' + i(TT));
    end else begin
      InitializeQMap;
      KillWeakestPlayer(WP, 0, FT, TT);
      if FT > 100 then FT:= FT - 100;
      if TT > 100 then TT:= TT - 100;
      FromTerritory:= FT;
      ToTerritory:= TT;
    end;
    bs(87, TOwner(ToTerritory));
    bs(68, ToTerritory);
    bs(69, FromTerritory);
    exit;
  end;


  //if (bg(94) = 0) then begin
  if FromTerritory = 0 then begin
    ArmySort(Army);
    RankSort(Rank);
    if Rank[SAlivePlayersCount] <> PMe then begin
      WP:= Rank[SAlivePlayersCount];

      y:= 0;
      Z:= 0;
     // OldMaxCost:= MaxCost;
      Repeat
        if (y = 1) then begin
          l('************************************************************second weakest');
          if (Rank[SAlivePlayersCount - 1] <> PMe) then WP:=Rank[SAlivePlayersCount - 1] else break;
        end;
        l('bg89 ' + i(bg(89)) + ' bg88 ' + i(bg(88)) + ' bg87 ' + i(bg(87)));
        if (not ( (WP = bg(89)) or (WP = bg(88)) or (WP = bg(87)) )) then begin
          KillWeakPlayerCheck(WP, 0, KillWP, Rank);
        end;
        if (y = 2) then begin
          if GameHasOneHuman(P) then begin
            WP:= P;
            If (PArmiesCount(PMe) + PNewArmies(PMe) - PTerritoriesCount(PMe) > PArmiesCount(WP) + PTerritoriesCount(WP))
            then begin
              KillWP:= True;
              m2('attempt kill human');
            end;
          end;
        end;

{
for p:= 1 to 10 do if (pos('frank', lowercase(PProgram(P))) > 0) and PAlive(p) then begin
  killwp:= true;
  WP:= P;
end;
}
        Repeat
          Z:= Z + 1;
          If KillWP then begin
            bs(86, 0);  // reset Owner of ToTerritory
            bs(77, 0);   // reset bestFT
            bs(79, 0);
            bs(80, 0);
            bs(82, 0);
            //UTakeSnapShot('killwp, ' + PName(wp) + ' turn: ' + i(bg(81)));
            KillBoth:= False;                                                  // in case the placement proc determined that I can't kill the WP
            if (SAlivePlayersCount = 3) and (Rank[1] = PMe) and (Z = 1) and (bg(89) = 0) then begin
              PAC:= 0;
              For T:= 1 to 42 do if TIsFront(T) and (TArmies(T) > 1) then PAC:= PAC + TArmies(T) - 1;
              if PAC > PArmiesCount(Rank[2]) + PTerritoriesCount(Rank[2]) + PArmiesCount(Rank[3]) + PTerritoriesCount(Rank[3]) + 5 then begin
                m2('try to kill both');
                KillBoth:= True;
                InitializeQMapKillBoth(WP);
                WPArmies:= PArmiesCount(Rank[2]) + PArmiesCount(Rank[3]);
              end;
            end;
            if not KillBoth then begin
              Z:= Z + 1;
              InitializeQMap;
              WPArmies:= PArmiesCount(WP);
            end;
  //          FirstFT:= 0;
  //          FirstTT:= 0;
            l('');
            l('WP= ' + PName(WP));
            x:= 400;
            //c:= 0;
            LastTT:= 0;
            Repeat
              x:= x + 2;
              FT:= 0;
              TT:= 0;
                // sometimes the occupation routine determines where the next attack should be and stores it in buffer 73
              if (bg(73) > 0) then begin // and (TArmies(bg(73)) > 1) and TIsMine(bg(73)) then begin // tarmies can be 1 or 2 when occupation routine is not called because the fromterritory has no armies with which to occupy
                FT:= bg(73);
                //KillPlayerAttack2(bg(74), FT, TT);
                //if TT = 0 then FT:= 0;
                TT:= bg(74);
                if FT > 0 then m('2 buffer 73 code, FT: ' + i(FT) + ' TT: ' + i(TT));
              end;
              if FT = 0 then begin
                bs(98, 0);
                bs(99, 0);
                KillWeakestPlayer(WP, LastTT, FT, TT);
                if (FT = 0) and (LastTT > 0) then KillWeakestPlayer(WP, 0, FT, TT);
                LastTT:= 0;
                          l('ft ' + i(ft) + ' tt ' + i(tt));
                //if (QTArmies[FT] = 2) and (QTArmies[TT] = 1) then begin
                 // m('shouldnt be making this attack');
                 // FT:=0;
                 // TT:=0;
                //end;
              end;
              if FT > 0 then begin
                bs(x, FT);
                bs(x+1, TT);
                bs(401, x);
               // if FirstFT = 0 then FirstFT:= FT;
               // if FirstTT = 0 then FirstTT:= TT;
                if TT > 100 then begin
                  if QTArmies[FT-100] > QTArmies[TT-100] then subtract:= QTArmies[TT-100] - 2 else subtract:= QTArmies[FT-100] - 1;
                  QTArmies[FT-100]:= QTArmies[FT-100] - subtract;
                  QTArmies[TT-100]:= QTArmies[TT-100] - subtract;
                end else begin
                  if (QTArmies[FT] <= QTArmies[TT]) then begin
                    m('QTArmies[ft] <= qtarmies[tt]');
                    if (QTArmies[FT] > 2) then begin
                      QTArmies[TT]:= QTArmies[TT] - QTArmies[FT] + 2;
                      QTArmies[FT]:= 2;
                    end;
                  end;
                  if QTArmies[FT] > QTArmies[TT] then begin
                    LastTT:= TT;
                    QTArmies[FT]:= QTArmies[FT] - QTArmies[TT];
                    if (QTArmies[TT] > 3) and (QTArmies[TT] < 9) and (QTArmies[FT] > 1) then QTArmies[FT]:= QTArmies[FT] - 1;
                    If QTOwner[TT] = WP then begin
                      WPArmies:= WPArmies - TArmies(TT);
                    end;
                    l('                                                WPArmies: ' + i(wparmies));
                    QTOwner[TT]:= PMe;
                    if QTArmies[FT] = 1 then QTArmies[TT]:= 1 else begin
                      // occupy with the mandatory minimum
                      if (QTArmies[FT] = 2) or (QTArmies[FT] = 3) then begin
                        QTArmies[TT]:= QTArmies[FT] - 1;
                        QTArmies[FT]:= 1;
                      end;

                      if QTArmies[FT] > 3 then begin
                        QTArmies[FT]:= QTArmies[FT] - 3;
                        QTArmies[TT]:= 3;

                        // bug control
                        if QTArmies[FT] < 1 then begin
                          QTArmies[FT]:= 1;
                          m2('bug control1');
                        end;
                        if QTArmies[TT] < 1 then begin
                          QTArmies[TT]:= 1;
                          m2('bug control2');
                        end;

                        KillPlayerOcc(WP, FT, TT, Armies);

                        if Armies = -1000 then begin
                        //l('its here1');
                          FT:= 0;
                          bs(73, 0);
                          bs(74, 0);
                        end else begin
                          //if TT = 29 then m('armies: ' + i(Armies));
                          QTArmies[FT]:= QTArmies[FT] - Armies;
                          QTArmies[TT]:= QTArmies[TT] + Armies;
                          l('after occ qtarmies[ft] ' + i(qtarmies[ft]) + ' qtarmies[tt] ' + i(qtArmies[tt]));
                        end;
                      end;
                    end;
                  end;
                end;
              end;
            Until (FT = 0) or (x > 482) or (WPArmies = 0);

            // check to see if it's still wise to kill the player now that we know how much it will cost
            if (WPArmies = 0) and (SAlivePlayersCount > 4) then begin
              QArmySort(Army, QMyTC, QMyAC);
              //QRankSort(
              if y < 2 then begin
                if GameHasOneHuman(P) then begin
                  KillValue:= round(double(TIV) * double(PCardCount(WP))/3);
                  if QMyAC + KillValue + 5 < PArmiesCount(PMe) then begin
                    WPArmies:= -1;
                    m2('abort KillWP, gamehasonehuman, QMyAC + KillValue + 5 < PArmiesCount(PMe)');
                  end;
                end else begin
                  if TContinent(Army[1]) = 2 then begin
                    if not ( (QTArmies[Army[2]] > 7) and (TContinent(Army[2]) <> 2) ) then begin
                      if not ( (Army[1] = 12) and (QTOwner[14] <> PMe) and (QTArmies[14] < CForce) and (QTArmies[12] > 2 * QTArmies[14]) ) then begin
                        C:= 0;
                        For a:= 1 to 9 do if QTOwner[a] = PMe then C:= C + 1;
                        if C < 3 then begin
                          WPArmies:= -1;
                          m2('abort kill in SA');
                        end;
                      end;
                    end;
                  end;
                  MaxTIV:= 0;
                  For P:= 1 to 10 do begin
                    if PAlive(P) and (P <> PMe) and (PCardTurnInValue(P) > MaxTIV) then MaxTIV:= PCardTurnInValue(P);
                  end;
                  l('QMyAC ' + i(QMyAC) + ' QMyTC ' + i(qmytc) + ' TIV ' + i(TIV) + ' MaxTIV ' + i(MaxTIV));
                  if (PCardCount(PMe) + PCardCount(WP) >= 5) then begin
                    if QMyAC {- QMyTC}  + TIV < 20 then WPArmies:= -1;
                    if QMyAC - QMyTC + TIV < MaxTIV then begin
                      m2('abort killwp, < MaxTIV');
                      WPArmies:= -1;
                    end;
                  end else begin
                    if QMyAC {- QMyTC} < 20 then WPArmies:= -1;
                    if QMyAC - QMyTC < MaxTIV then begin
                      m2('abort killwp, < MaxTIV');
                      WPArmies:= -1;
                    end;
                  end;



                  if WPArmies = -1 then begin
                    {
                    if bg(87) = 0 then begin
                      bs(87, WP);
                    end else begin
                      bs(88, WP);
                    end;
                    }
                    if m2('abort killwp, My Armies will be less than 20') then exit;
                  end;
                end;
              end else begin
                // any code to abort killing human?
              end;
            end;

            if WPArmies = 0 then begin

              // sort the attacks so that the most risky attacks are done first
              FT:= 0;
              TT:= 0;
              start:= 0;
              finish:= 0;
              For a:= 402 to bg(401) do begin
          //     l('a ' + i(a) + ' bg(a) ' + i(bg(a)));
              end;

              For a:= 402 to bg(401) do begin
             //   l('a ' + i(a) + ' bg(a) ' + i(bg(a)) + ' ft ' + i(ft) + ' tt ' + i(tt));
                if (TT > 0) and (bg(a) <> TT) and (bg(a) <> FT) then begin
                  C:= 0;
                  if (bg(a - 2) > 100) and (bg(a -1) > 100) then C:= C + 1; //don't start a resort if the last ft and tt were just going to weaken a T
                  bga:= bg(a);
                  if bga > 100 then bga:= bga - 100;
                  For b:= a - 1 downto 402 do begin
                    bgb:= bg(b);
                    if bgb > 100 then bgb:= bgb - 100;
                //    l('1 b ' + i(b) + ' bg(b) ' + i(bg(b)) + ' bgb ' + i(bgb));
                    if bga = bgb then C:= C + 1;
                  //  l('c ' + i(c));
                  end;
                  if C = 0 then begin
                    start:= a;
                    finish:= 0;
               //     l('start ' + i(start));
                    if start = bg(401) then finish:= bg(401) + 1 else begin
                      For b:= start + 1 to bg(401) do begin
                        if finish = 0 then begin
                          b:= b + 1;
                          bgb:= bg(b);
                          if bgb > 100 then bgb:= bgb - 100;
                          bgb1:= bg(b - 1);
                          if bgb1 > 100 then bgb1:= bgb1 - 100;
                         // l('2 b ' + i(b));
                          if bgb <> bgb1 then begin
                            finish:= b - 1;
                         //   l('finish ' + i(finish));
                          end;
                        end;
                      end;
                      if finish = 0 then finish:= bg(401) + 1;
                    end;
                  end;
                end;
                FT:= bg(a);
                if FT > 100 then FT:= FT - 100;
                TT:= bg(a + 1);
                if TT > 100 then TT:= TT - 100;
                a:= a + 1;
              end;
              if start > 0 then if m2('start ' + i(start) + ' finish ' + i(finish)) then exit;
              if start > 0 then begin
                SetArrayLength(ReOrder, bg(401) + 2);
                b:= 0;
                for a:= start to finish do begin
                  b:= b + 1;
                  ReOrder[b]:= bg(a);
                end;
                for a:= 402 to bg(401) + 1 do begin
                  if (a >= start) and (a <= finish) then continue;
                  b:= b + 1;
                  ReOrder[b]:= bg(a);
                end;
                b:= 0;
              //  l(' ');
               // l('New Order');
                for a:= 402 to bg(401) + 1 do begin
                  b:= b + 1;
                  bs(a, ReOrder[b]);
                //  l('a ' + i(a) + ' bg(a) ' + i(bg(a)));
                end;
              end;

              if KillBoth then m2('killboth');


              bs(77, 0); // reset BestFT
              bs(79, 0);
              bs(80, 0);
              if x >= 404 then bs(400, 1); // if the path length is more than one then use the stored path
              if bg(402) > 100 then begin
                FromTerritory:= bg(402) - 100;
                ToTerritory:= bg(403) - 100;
                m2('*** killwp weaken, FT: ' + i(FromTerritory) + ' TT: ' + i(ToTerritory) + ' MaxCost: ' + i(MaxCost) + ' WP: ' + PName(WP));
                bs(63, WP);
                bs(98, ToTerritory);
                bs(99, FromTerritory);
              end else begin
                FromTerritory:= bg(402); //FirstFT;
                ToTerritory:= bg(403); //FirstTT;
                m2('*** killwp, FT: ' + i(FromTerritory) + ' TT: ' + i(ToTerritory) + ' MaxCost: ' + i(MaxCost) + ' WP: ' + PName(WP));
                bs(63, WP);
                bs(68, ToTerritory);
                bs(69, FromTerritory);
                //qmap:= '';
                //For T:= 1 to 42 do qmap:= qmap + ' T ' + i(T) + ' qtArmies ' + i(QTArmies[T]);
                //UTakeSnapShot(qmap);
              end;
            end else begin
              bs(400, 0);
            end;
          end;  // end if KillWP
        until (FromTerritory > 0) or (z >= 2);
        if x > 482 then m('pause x > 482');
        y:= y + 1;
      until (FromTerritory > 0) or (y = 3);
    end; // end "if Rank[SAlivePlayersCount] <> PMe"
    //if bg(400) = 0 then bs(94, 1);  // don't check again this turn
    if FromTerritory > 0 then begin
      bs(86, TOwner(ToTerritory));
      exit;
    end else bs(63, 0);
  end;
//        If FromTerritory = 0 then begin
          //if bg(63) > 0 then m('end killwp FT = 0, maxCost: ' + i(maxcost) + ' WP: ' + PProgram(WP));
//          bs(63, 0);
//        end;

  {---------------------------------------- Weaken player code --------------------------------------------}

  if ((SAlivePlayersCount = 4) or (SAlivePlayersCount = 3)) and (not KillWP) then begin
    cRankSort(Rank, PArmies, MyArmies);
    for x:= 1 to SAlivePlayersCount do begin
      l('Rank ' + i(x) + ' ' + PProgram(Rank[x]) + ' Armies ' + i(PArmies[x]));
    end;
    l('MyArmies ' + i(MyArmies));
    if (PArmiesCount(PMe) > 150) and (not (Rank[SAlivePlayersCount] = PMe)) then begin
      if (SAlivePlayersCount = 3) and (Rank[1] <> PMe) then begin
    //  Total:= 0;
   //   for P:= 2 to SAlivePlayersCount do Total:= Total + PArmies[P];
  //    if (not (PArmies[1] > trunc(0.8 * double(Total)) )) then begin
        InitializeQMap;
        Weaken1:= True;
        FT:= 0;
        TT:= 0;
        KillWeakestPlayer(Rank[1], 0, FT, TT);
        if FT > 100 then FT:= FT - 100;
        if TT > 100 then TT:= TT - 100;
        FromTerritory:= FT;
        ToTerritory:= TT;
        if ToTerritory > 0 then begin
          if (TOwner(ToTerritory) <> Rank[1]) then begin
            bs(68, ToTerritory);
            bs(69, FromTerritory);
          end else begin
            if (PArmies[1] - PArmies[3] > TArmies(ToTerritory)) then begin
              bs(68, ToTerritory);
              bs(69, FromTerritory);
            end else begin
              bs(85, PArmies[1] - PArmies[3]);
              m2('bg85 ' + i(bg(85)));
              bs(98, ToTerritory);
              bs(99, FromTerritory);
            end;
          end;

          //bs(63, Rank[1]);
          if m2('weaken rank1') then exit;
        end;

        if (SAlivePlayersCount = 3) and (Rank[1] = PMe) then begin
          InitializeQMap;
          Weaken1:= True;
          FT:= 0;
          TT:= 0;
          KillWeakestPlayer(Rank[2], 0, FT, TT);
          if FT > 100 then FT:= FT - 100;
          if TT > 100 then TT:= TT - 100;
          FromTerritory:= FT;
          ToTerritory:= TT;
          if ToTerritory > 0 then begin
  //          if (MyArmies - TArmies(ToTerritory) > PArmies[3]) and (TOwner(ToTerritory) = Rank[2]) then begin
  //            bs(68, ToTerritory);
  //            bs(69, FromTerritory);
  //          end;
            if (TOwner(ToTerritory) <> Rank[2]) then begin
              bs(68, ToTerritory);
              bs(69, FromTerritory);
            end else begin
              if (MyArmies - TArmies(ToTerritory) > PArmies[3]) then begin
                bs(68, ToTerritory);
                bs(69, FromTerritory);
              end else begin
                bs(85, MyArmies - PArmies[3]);
                m2('bg85 ' + i(bg(85)));
                bs(98, ToTerritory);
                bs(99, FromTerritory);
              end;
            end;

            if m2('weaken rank2') then exit;
            //bs(63, Rank[2]);
          end;
        end;

        if (SAlivePlayersCount = 4) and (Rank[3] = PMe) then begin
          if (PArmies[2] > trunc(0.9 * double(PArmies[1]))) and (PArmies[3] > trunc(0.5 * double(PArmies[1]))) then begin
            InitializeQMap;
            Weaken1:= True;
            FT:= 0;
            TT:= 0;
            KillWeakestPlayer(Rank[4], 0, FT, TT);
            if FT > 100 then FT:= FT - 100;
            if TT > 100 then TT:= TT - 100;
            FromTerritory:= FT;
            ToTerritory:= TT;

            if ToTerritory > 0 then begin
              //bs(63, Rank[4]);
              if m2('weaken rank4') then exit;
            end;
          end;
        end;
      end;
    end;
    if ToTerritory > 0 then exit;
  end;

  {------------------------------------------ATTACK STRONG PLAYER---------------------------------------}

  If (FromTerritory = 0) then begin
    l('begin attack sp');
    cRankSort(Rank, PArmies, MyArmies);
    SP:= 0;
    AttackSP:= false;
    Weaken:= false;
    if GameHasNoHumans or PHuman(Rank[1]) then begin
      if (Rank[1] <> PMe) and (MyArmies > 20) and (MyArmies > (PArmies[1] * 2) div 3) then begin
        If (( pos('wyrm', lowercase(PProgram(Rank[1]))) > 0 ) or PHuman(Rank[1])) and (SAlivePlayersCount < 6) then AttackSP:= true;
        If (Rank[1] <> PME) and ((PArmies[1] * 9) div 10 > PArmies[2])
         and (SAlivePlayersCount < 7)
         and (  ( pos('frank', lowercase(PProgram(Rank[1]))) > 0 )
         or ( pos('australian09', lowercase(PProgram(Rank[1]))) > 0 )  ) then AttackSP:= true;
        If (Rank[1] <> PME) and ((PArmies[1] * 4) div 5 > PArmies[2])
         and (SAlivePlayersCount < 6)
         and ( pos('struggler', lowercase(PProgram(Rank[1]))) > 0 ) then AttackSP:= true;
        If (Rank[1] <> PME) and ((PArmies[1] * 3) div 4 > PArmies[2])
         and (SAlivePlayersCount < 5) then AttackSP:= true;
      end;
    end;
    if attacksp then l('1 attack sp');
//    OneHuman:= GameHasOneHuman(P);
    if SCardsBasedOnCombo and GameHasOneHuman(P) then AttackSP:= true;

    if not SCardsBasedOnCombo then SP:= Rank[1] else begin
      if GameHasOneHuman(P) then SP:= P else SP:= Rank[1];
    end;
    l('sp: ' + i(sp));
    //  attacksp:= true; sp:= 2;
    if attackSP and (SP > 0) then begin
      m2('attempt attack strong player');
      AttackStrongPlayer(SP, Weaken, FromTerritory, ToTerritory)
      if FromTerritory > 0 then exit;
    end else begin
      bs(60, 0);
      bs(100, 0);
      bs(101, 0);
    end;
  end;

  {-------------------------------------------FLOAT ATTACK CODE--------------------------------------}

  if bg(63) = 0 then begin // ie if not kill player mode then begin

    if TOwner(39) = PMe then begin
      CAnalysis(6, PT, PA, ET, EA);
      if (EA > 0) then begin
        // dont take australia if all of my armies are in australia - dont get trapped in a dead end
        if (not ( (PArmiesCount(PMe) - PTerritoriesCount(PMe)) = (PA - PT) )) and (PA - PT > EA + ET) then begin
          For T:= 39 to 42 do begin
            if TIsFront(T) and (TArmies(T) > 1) then begin
              for T1:= 40 to 42 do begin
                if (TOwner(T1) <> PMe) and (not ( (TArmies(T) < 4) and (TArmies(T1) > 1) )) and TIsBordering(T, T1) then begin
                  FromTerritory:= T;
                  ToTerritory:= T1;
                end;
              end;
            end;
          end;
        end;
      end;
    end;

    ArmySort(Army);

    if (TContinent(Army[1]) = 2) and (SAlivePlayersCount > 3) then begin
 //     m2('1 start new code, cForce ' + i(Cforce));
      if (not ( (TContinent(Army[2]) <> 2) and (TArmies(Army[2]) > 7) )) then begin
 //       m2('2 start new code, cForce ' + i(Cforce));
        CAnalysis(1, PT, PA, ET, EA);
        if PT < 3 then begin
          if (Army[1] <> 12) and (TOwner(12) <> PMe) and (TArmies(12) < CForce * 2) and (TArmies(Army[1]) > TArmies(12) * 2) then begin
            m2('attack 12');
            FromTerritory:= Army[1];
            ToTerritory:= 12;
            bs(68, ToTerritory);
            bs(69, FromTerritory);
          end;
          if (Army[1] = 12) and (TOwner(14) <> PMe) and (TArmies(14) < CForce * 2) and (TArmies(Army[1]) > TArmies(14) * 2) then begin
            m2('attack 14');
            FromTerritory:= Army[1];
            ToTerritory:= 14;
            bs(68, ToTerritory);
            bs(69, FromTerritory);
          end;
        end;
      end;
      if FromTerritory > 0 then exit;
    end;

    //if bg(61) > 0 then
    l('CForce: ' + i(Cforce) + ' bg(61): ' + i(bg(61)));

    //if PArmiesCount(PMe) > 200 then CForce:= CForce * 2;
    if (not SConquest) and (FromTerritory = 0) then begin
      {
      //For T:= 1 to 42 do Points[T]:= 0;
      MaxPoints:= 0;
      For T:= 1 to 42 do begin
        if TIsFront(T) and (TArmies(T) > 1) then begin
          For B:= 1 to TBordersCount(T) do begin
            aPoints:= 0;
            BT:= TBorder(T, B);
            if TIsMine(BT) then continue;
            if TArmies(BT) > CForce then continue;
            if (TArmies(T) < 4) and (TArmies(BT) > 1) then continue;
            aPoints:= 1/double(TArmies(BT));
            For B1:= 1 to TBordersCount(BT) do begin
              BT1:= TBorder(BT, B1);
              if (not TIsMine(BT1)) and (TArmies(BT1) <= CForce) then begin
                aPoints:= 1/double(TArmies(BT)) + 1/double(TArmies(BT1));
                l('BT ' + i(bt) + ' BT1 ' + i(BT1) + ' points: ' + f(apoints));
                if (aPoints = MaxPoints) {and (BT <> ToTerritory) then begin
                  if TArmies(BT) = TArmies(ToTerritory) then begin
                    l('TArmies(BT) = TArmies(ToTerritory)' + ' TT2 ' + i(tt2));
                    go:= false;
                    if BT <> ToTerritory then begin
                      TWeakestFront(ToTerritory, ET, EA);
                      C:= 0;
                      For B2:= 1 to TBordersCount(ToTerritory) do begin
                        BT2:= TBorder(ToTerritory, B2);
                        if TOwner(BT2) = PMe then continue;
                        if TArmies(BT2) = EA then C:= C + 1;
                      end;
                      C1:= 0;
                      For B2:= 1 to TBordersCount(BT) do begin
                        BT2:= TBorder(BT, B2);
                        if TOwner(BT2) = PMe then continue;
                        if TArmies(BT2) = EA then C1:= C1 + 1;
                      end;
                      if C1 > C then begin
                        go:= true;
                        l('1 c1 > c');
                      end;
                      if C1 = C then begin
                        C:= 0;
                        For B2:= 1 to TBordersCount(ToTerritory) do begin
                          BT2:= TBorder(ToTerritory, B2);
                          if TOwner(BT2) = PMe then continue;
                          if TArmies(BT2) <= CForce then C:= C + 1;
                        end;
                        C1:= 0;
                        For B2:= 1 to TBordersCount(BT) do begin
                          BT2:= TBorder(BT, B2);
                          if TOwner(BT2) = PMe then continue;
                          if TArmies(BT2) <= CForce then C1:= C1 + 1;
                        end;
                        if C1 > C then begin
                          go:= true;
                          l('2 c1 > c');
                        end;
                      end;
                    end;
                    if not go then begin
                      WFA1:= 0;
                      WFA:= 0;
                      For B2:= 1 to TBordersCount(TT2) do begin
                        BT2:= TBorder(TT2, B2);
                        if BT2 = ToTerritory then continue;
                        if TIsMine(BT2) then continue;
                        if TArmies(BT2) > CForce then continue;
                        if (TArmies(BT2) < WFA) or (WFA = 0) then WFA:= TArmies(BT2);
                      end;
                      For B2:= 1 to TBordersCount(BT1) do begin
                        BT2:= TBorder(BT1, B2);
                        if BT2 = BT then continue;
                        if TIsMine(BT2) then continue;
                        if TArmies(BT2) > CForce then continue;
                        if (TArmies(BT2) < WFA1) or (WFA1 = 0) then WFA1:= TArmies(BT2);
                      end;
                      l('WFA ' + i(WFA) + ' WFA1 ' + i(WFA1));

                      if WFA = WFA1 then begin
                        //if (TFrontsCount(BT) < TFrontsCount(ToTerritory)) and (Not (TFrontsCount(BT) = 1)) then go:= true else
                         if TArmies(T) < TArmies(FromTerritory) then go:= true; // favor using up a smaller army
                      end;
                      if ((WFA = 0) and (WFA1 > 0)) or ((WFA1 < WFA) and (WFA1 > 0)) then go:= true;
                    end;
                    if go then begin
                      FromTerritory:= T;
                      ToTerritory:= BT;
                      TT2:= BT1;
                      m2('WFA, TT: ' + i(ToTerritory) + ' TT2 ' + i(TT2));
                    end;
                  end;
                  if TArmies(BT) < TArmies(ToTerritory) then begin
                    FromTerritory:= T;
                    ToTerritory:= BT;
                    TT2:= BT1;
                    l('TArmies(BT) < TArmies(ToTerritory), TT: ' + i(ToTerritory) + ' TT2 ' + i(TT2));
                  end;
                end;
              end;
              if aPoints > MaxPoints then begin
                MaxPoints:= aPoints;
                FromTerritory:= T;
                ToTerritory:= BT;
                TT2:= BT1;
                l('Points > MaxPoints, TT: ' + i(ToTerritory) + ' points ' + f(apoints) + ' TT2 ' + i(TT2));
               end;
            end;
          end;
        end;
      end;
      m2('pause 1')
    //end;
      firstTT:= ToTerritory;
      firstFT:= FromTerritory;
      }

      MaxPoints:= 0;
      For T:= 1 to 42 do begin
        if TIsFront(T) and (TArmies(T) > 1) then begin
          Coef:= 0;
          For B:= 1 to TBordersCount(T) do begin
            BT:= TBorder(T, B);
            if TIsMine(BT) then continue;
            if TArmies(BT) > CForce then continue;
            if (TArmies(T) < 4) and (TArmies(BT) > 1) then continue;
            Coef:= Coef + 1/double(TArmies(BT));
          end;
          Coef:= Coef * 2.94;
          l('coef ' + f(coef));
          For B:= 1 to TBordersCount(T) do begin
            BT:= TBorder(T, B);
            if ((T = 14) and (BT = 12)) or ((T = 9) and (BT = 10)) then continue; // dont go into SA
            if TIsMine(BT) then continue;
            if TArmies(BT) > CForce then continue;
            if (TArmies(T) < 4) and (TArmies(BT) > 1) then continue;
            aPoints:= Coef * 1/double(TArmies(BT));
            MinArmy:= 0;
            For B1:= 1 to TBordersCount(BT) do begin
              BT1:= TBorder(BT, B1);
              if (not TIsMine(BT1)) and (TArmies(BT1) <= CForce) then begin
                aPoints:= aPoints + 1/double(TArmies(BT1));
              end;
              if (not TIsMine(BT1)) and ((TArmies(BT1) < MinArmy) or (MinArmy = 0)) then begin
                MinArmy:= TArmies(BT1);
              end;
            end;
            l('bt ' + i(BT) + ' points ' + f(apoints));
            go:= false;
            if (aPoints = MaxPoints) and (MinArmy < oMinArmy) then go:= true;
            if aPoints > MaxPoints then go:= true;
            if go then begin
              MaxPoints:= aPoints;
              FromTerritory:= T;
              ToTerritory:= BT;
              oMinArmy:= MinArmy;
            //  TT2:= BT1;
              l('Points > MaxPoints, TT: ' + i(ToTerritory) + ' points ' + f(apoints) + ' TT2 ' + i(TT2));
            end;
          end;
        end;
      end;
     // m2('pause 1')
    //end;
      {
      firstTT:= ToTerritory;
      firstFT:= FromTerritory;

      TWithWeakestFront(TWF, WF, WFA);
      For T:= 1 to 42 do Points[T]:= 0;
      MaxPoints:= 0;
      For T:= 1 to 42 do begin

        if TIsFront(T) and (TArmies(T) > 1) then begin
          For E:= 1 to 42 do begin
            If (Not TIsMine(E)) and (TArmies(E) <= CForce) then begin
              If QTWeakestPath(T, E, 0, TT, PL, EA) then begin
                if EA < (PL * 2) + CForce then Points[TT]:= Points[TT] + 1/double(EA);
                if (TOwner(TT) = Rank[1]) and (Rank[1] <> Pme) then Points[TT]:= Points[TT] + 1/double(EA);
                if pos('frank', lowercase(PProgram(TOwner(TT)))) > 0 then Points[TT]:= Points[TT] + 1/double(EA);
                if pos('09', lowercase(PProgram(TOwner(TT)))) > 0 then Points[TT]:= Points[TT] + 1/double(EA);
//                if pos('wyrm', lowercase(PProgram(TOwner(TT)))) > 0 then Points[TT]:= Points[TT] + 1/double(EA);
                if (TContinent(TT) = 2) and (PArmiesCount(PMe) < 100) and (TContinent(T) <> 2) then Points[TT]:= 0;
                TWeakestFront(T, ET, EA1);
                if TArmies(TT) = EA1 then Points[TT]:= Points[TT] + 1/double(EA);
                
                if (Points[TT] > MaxPoints) then begin
                  OldMaxPoints:= MaxPoints;
                  MaxPoints:= Points[TT];
                  MaxArmy:= 1;
                  For B:= 1 to TBordersCount(TT) do begin
                    BT:= TBorder(TT, B);
                    if TIsMine(BT) and (TArmies(BT) > MaxArmy) then begin
                      MaxArmy:= TArmies(BT);
                      FromTerritory:= BT;
                      ToTerritory:= TT;
                    end;
                  end;
                  If FromTerritory = 0 then begin
                    ToTerritory:=0;
                    MaxPoints:= OldMaxPoints;
                  end;
                end;
              end
            end;
          end;
        end;
      end;
      //if (FromTerritory > 0) and (bg(75) > 0) then l('2nd attack, FT: ' + i(FromTerritory) + ' TT: ' + i(ToTerritory));

      if not( (TArmies(FromTerritory) > 50) and (TArmies(ToTerritory) < 5) ) then begin
        if (TArmies(ToTerritory) > CForce)
        or ( (TArmies(FromTerritory) < 4) and (TArmies(ToTerritory) > 1) )
        or (   (  TArmies(FromTerritory) < round( 0.85 * TArmies(ToTerritory) )  ) and (not (SAlivePlayersCount = 2))   ) then begin
          FromTerritory:= 0;
          ToTerritory:= 0;
        l('attack overidden1, cforce: ' + i(CForce));
        end;
      end;
      }
      if (ToTerritory = 0) and (bg(75) = 0) then begin // look for the attack with the best chance to win
        m('secondary float attack');
        MaxPoints:=0;
        for T:=1 to 42 do begin
          aPoints:= 0;
          if TIsFront(T) and (TArmies(T) > 2) then begin
            TWeakestFront(T, ET, EA);
            aPoints:= aPoints + (1/double(EA)) - (1/double(TArmies(T)));
            if (aPoints > MaxPoints) then begin
              MaxPoints:= aPoints;
              FromTerritory:= T;
              ToTerritory:= ET;
            end;
          end;
        end;
      end;

    end;

    // this code overides the above decision if it's a bad one
    if pos('struggler', lowercase(PProgram(TOwner(ToTerritory)))) > 0 then begin
      if TArmies(ToTerritory) > CForce then m2('double CForce for attacking struggler with a secondary float attack');
      CForce:= CForce * 2;
    end;
    if not( (TArmies(FromTerritory) > 50) and (TArmies(ToTerritory) < 5) ) then begin
      if (TArmies(ToTerritory) > CForce)
      or ( (TArmies(FromTerritory) < 4) and (TArmies(ToTerritory) > 1) )
      or (   (  TArmies(FromTerritory) < round( 0.85 * TArmies(ToTerritory) )  ) and (not (SAlivePlayersCount = 2))   )
      and (not (PArmiesCount(PMe) > 100)) then begin
        FromTerritory:= 0;
        ToTerritory:= 0;
        if not scardsbasedoncombo then m2('attack overidden2, cforce: ' + i(CForce));
      end;
    end;
    {
    if ToTerritory <> FirstTT then m2('different, TT: ' + i(Toterritory) + ' firstTT ' + i(firstTT));
    if FirstTT > 0 then begin
      ToTerritory:= FirstTT;
      FromTerritory:= FirstFT;
    end;
    }
    bs(68, ToTerritory);
    bs(69, FromTerritory);

  end; // end if bg(63) = 0
end; // end procedure Attack

procedure Occupation(FromTerritory, ToTerritory: integer; var Armies: integer);
var
  T, TTNeeds, iNode, iChild, B1, BT1, BT, PT, PA, EA1, ET1, EA, ET, B, CForce,
  PL, TT, MinCost, FTNeeds, FTNeeds_WP, TTNeeds_WP, C, P, X, Count, FTA: integer;
  TTCanAttack, FTCanAttack: boolean;
  Army: array of integer;
  {
  Node: array [1..42] of record
    Closed: boolean;
    TTOpen: boolean;
    FTOpen: boolean;
  end;
  }
begin
//  m2('begin occ');
  bs(70, 1);  // notifies the attack proc that the occ proc was called

  if (TArmies(ToTerritory) = 1) and (TArmies(FromTerritory) > 5) then m('found bug');
  If ToTerritory = bg(71) then bs(72, bg(72)+1) else begin
    bs(71, ToTerritory);     // 71 - Keeps track of the last territory I conquered
    bs(72, 0);               // 72 - Keeps track of how many times I've attacked the same territory
  end;
  bs(60, 0); // reset attack determined by strong player code
  bs(61, 0);    // 61 - successive turns without conquest counter
  bs(68, 0);   // 68 - keeps track of the last territory I attacked
  bs(69, 0);   // 69 - keeps track of the last territory I attacked from

  bs(91, 0);    // reset the last T I occupied

  ConquestForce(CForce);
  FTA:= TArmies(FromTerritory) - 1;
  Armies:=FTA;  // Default is to occupy all
  ArmySort(Army);

  // buffer 67 = 1 is a signal not to occupy the territory
  if bg(67) > 0 then begin
    If bg(67) = 1 then Armies:= 0
     else begin
      Armies:= bg(67);
      If Armies > FTA then Armies:= FTA;
    end;
    bs(67, 0);
    m2('buffer 67 occ, Armies: ' + i(armies));
    exit;
  end;
  //l('occ armies: ' + i(armies));
  {------------------------------Kill Player Occupation------------------------------------------}
  if (bg(64) = 100) or ( (bg(63) > 0) and PAlive(bg(63)) ) then begin
   // l('start kill player occ');
    P:= bg(63);
    if bg(64) = 100 then P:= 0;

    if KillBoth then InitializeQMapKillBoth(P) else InitializeQMap;
    KillPlayerOcc(P, FromTerritory, ToTerritory, Armies);
    exit;
  end;
  {---------------------------------------------------------------------------------------------}
  // take australia occupation
  if (FromTerritory = 31) and (ToTerritory = 39) then begin
    CAnalysis(6, PT, PA, ET, EA);
    Armies:= ET + EA - (PA - PT);
    if TArmies(31) > Armies + 2 Then Armies:= Armies + 2;
    if TArmies(31) > Armies + 2 Then Armies:= Armies + 2;
    If Armies > FTA then Armies:= FTA;
    exit;
  end;

  {------------------------------Continents Occupation-----------------------------------------------}
  // buffer 90 means that the attack code was from the continents section
  {
  if bg(92) > 0 then bs(91, bg(92));
  if (TContinent(ToTerritory) = 2) and (bg(90) > 0) then begin
    if COwner(2) = PMe then begin
      m('sihng gung');
      bs(93, 1);  //tells the fortification routine to pause the game
    end;
    // default is Armies:= FTA;
    bs(91, ToTerritory);
    C:= 2;
    if (FromTerritory = 12) then Armies:= ((FTA + CEA(C)) * 2) div 5;
    if (FromTerritory = 10) then Armies:= ((FTA + CEA(C)) * 3) div 5;
    if Armies > FTA then Armies:= FTA;
    exit;
  end;
  }

  {------------------------------Float Attack Occupation---------------------------------------------}
  TTCanAttack:= False;
  FTCanAttack:= False;
  For B:= 1 to TFrontsCount(FromTerritory) do begin
    BT:= TFront(FromTerritory, B);
    If TArmies(BT) <= CForce then FTCanAttack:= true;
  end;
  For B:= 1 to TFrontsCount(ToTerritory) do begin
    BT:= TFront(ToTerritory, B);
    If TArmies(BT) <= CForce then TTCanAttack:= true;
  end;
  If FTCanAttack then Armies:= 0;
  If TTCanAttack then Armies:= FTA;
  If (Not TTCanAttack) and (Not FTCanAttack) then begin
    if TIsFront(ToTerritory) and TIsFront(FromTerritory) then begin
      TWeakestFront(ToTerritory, ET, EA);
      TWeakestFront(FromTerritory, ET1, EA1);
      If (EA1 < EA) and (ET1 > 0) then Armies:= 0 else Armies:= FTA;
    end else begin
      if TIsFront(FromTerritory) then Armies:= 0;
    end;
  end;

  // don't occupy to SA
  if (TContinent(ToTerritory) = 2) and (TContinent(FromTerritory) <> 2) then Armies:= 1;

  // occupy the T we've been trading back and forth to stop this from continuing
  If (bg(72) > 2) and (ToTerritory = bg(71)) then begin
    Armies:= FTA;
    if (FTA > TIV) and (FTA > 100) and (TArmies(Army[2]) < 4) then Armies:= FTA div 2;
    l('occupy the T weve been trading');
  end;
  //m2('end of occ armmies: ' + i(Armies));
     // Army is for defence
  //if AIFD(FromTerritory) and (FromTerritory = 12) and (ToTerritory = 14) then Armies:= 0;
  //m2('pause 2');
  {
  if SAlivePlayersCount = 3 then begin
  //  l('start 3 players left occ');
  // find out P and if KIllWP
    P:= 0;
    RankSort(Rank);
    if (not (Rank[3] = PMe)) then P:= Rank[3];
    C:= 0;
    if TIsFront(FromTerritory) and TIsFront(ToTerritory) and (P > 0) then begin
  //  m2('is front');
      For B:= 1 to TFrontsCount(ToTerritory) do begin
        BT:= TFront(ToTerritory, B);
       // l('bt ' + i(BT) + ' TFC ' + i(TFrontsCount(ToTerritory)) + ' FT ' + i(FromTerritory));
        if (not TIsBordering(BT, FromTerritory)) then begin
          C:= C + 1;
          break;
        end;
      end;
      For B:= 1 to TFrontsCount(FromTerritory) do begin
        BT:= TFront(FromTerritory, B);
       // l('bt ' + i(BT) + ' TFC ' + i(TFrontsCount(ToTerritory)) + ' FT ' + i(FromTerritory));
        if (not TIsBordering(BT, ToTerritory)) then begin
          C:= C + 1;
          break;
        end;
      end;
    end;

    If C > 0 then begin
      m2('C > 0');

      TTNeeds:= 0;
      TTNeeds_WP:=0;
      FTNeeds:= 0;
      FTNeeds_WP:= 0;

      for T:=1 to 42 do begin
        with Node[T] do begin
          Closed := false;
          TTOpen:= false;
          FTOpen:= false;
        end;
      end;

      Node[ToTerritory].TTOpen:= True;
      Node[FromTerritory].FTOpen:= True;

      Repeat
        T:= 0;
        iNode:= 0;
        repeat
          T:= T + 1;
          if Node[T].TTOpen and not Node[T].Closed then begin
            iNode:= T;
          end;
        until (iNode > 0) or (T = 42);

        if iNode <> 0 then begin
          for B:= 1 to TBordersCount(iNode) do begin
            iChild:= TBorder(iNode, B);
            if (TOwner(iChild) = PMe) then continue;

            if ((not Node[iChild].TTOpen) and (not Node[iChild].Closed)) then begin
              if TOwner(iChild) = P then TTNeeds_WP:= TTNeeds_WP + TArmies(iChild) + 1;
              TTNeeds:= TTNeeds + TArmies(iChild) + 1;
              if Node[iChild].Closed then Node[iChild].Closed:= false; // if closed then remove child from CLOSED list
              Node[iChild].TTOpen:= true;
            end;
          end;
          Node[iNode].Closed := true; // node has been examined, add to CLOSED list
        end;
      until (iNode = 0);  // loop until there are no more open nodes

      Repeat
        T:= 0;
        iNode:= 0;
        repeat
          T:= T + 1;
          if Node[T].FTOpen and not Node[T].Closed then begin
            iNode:= T;
          end;
        until (iNode > 0) or (T = 42);

        if iNode <> 0 then begin
          for B:= 1 to TBordersCount(iNode) do begin
            iChild:= TBorder(iNode, B);
            if (TOwner(iChild) = PMe) then continue;

            if ((not Node[iChild].FTOpen) and (not Node[iChild].Closed)) then begin
              if not Node[iChild].TTOpen then begin
                if TOwner(iChild) = P then FTNeeds_WP:= FTNeeds_WP + TArmies(iChild) + 1;
                FTNeeds:= FTNeeds + TArmies(iChild) + 1;
              end;
              if Node[iChild].Closed then Node[iChild].Closed:= false; // if closed then remove child from CLOSED list
              Node[iChild].FTOpen:= true;
            end;
          end;
          Node[iNode].Closed := true; // node has been examined, add to CLOSED list
        end;
      until (iNode = 0);  // loop until there are no more open nodes

      if FTNeeds = 0 then Armies:= FTA
       else begin
        if TTNeeds_WP > FTA then begin
          Armies:= FTA;
        end else if (FTNeeds_WP = 0) and (TTNeeds_WP > 0) then Armies:= TTNeeds + 3;

        if (FTNeeds_WP > 0) and (TTNeeds_WP > 0) then begin
          if FTNeeds_WP + TTNeeds < FTA then begin
            Armies:= TTNeeds + 3;
          end else if FTNeeds_WP + TTNeeds_WP < FTA then Armies:= TTNeeds_WP + 3;
        end;

        if (FTNeeds_WP > 0) and (TTNeeds_WP = 0) then Armies:= 0;

        if FTNeeds + TTNeeds < FTA then begin
          if TTNeeds > FTNeeds then Armies:= TTNeeds + 3 else Armies:= FTA - FTNeeds - 3;
        end else if (FTNeeds_WP + TTNeeds < FTA) then begin
          MinCost:= 0;
          For T:= 1 to 42 do begin
            if Node[T].FTOpen and (TOwner(T) = P) then begin
              QTWeakestPath(FromTerritory, T, 0, TT, PL, EA);
              if PL + EA < MinCost then MinCost:= PL + EA;
            end;
          end;
          if FTNeeds_WP + TTNeeds + MinCost + 6 < FTA then Armies:= TTNeeds + 3;
        end;

        if TTNeeds_WP = TTNeeds then Armies:= TTNeeds + 3;
        if Armies > FTA then Armies:= FTA;
        // what about PNewArmies?
      end;

    end;
    l('SAPC = 3, occupation, Armies: ' + i(Armies));
  end;
  }
end; // end procedure Occupation

{--------------------------Fortification--------------------------------------------------------------------}

procedure Fortification(var FromTerritory, ToTerritory, Armies: integer);
Var
  PT, PA, WF, MinPL, TT, MaxArmy, Y, X, CForce, MinEA, BT, ET, EA, ET1, EA1, PL, T, B: integer;
  Combine: boolean;
  Army: array of integer;
begin
  //UMessageOn;
  //umessage('stop');
  ArmySort(Army);

  ResetBuffers;
  if bg(93) > 0 then m('pause');
  bs(81, (bg(81) + 1));    // 81 - Stores a turn count that doesn't include initial placement
  bs(94, 0);     // 94 - reset don't check killwp until next turn
  if not SConquest then begin
    bs(61, bg(61)+1);   //  61 - successive turns without conquest counter
    bs(62, bg(62)+1);   //  62 - keeps track of how many total turns I've gone without conquest
  end;
  if SConquest then bs(61,0);
  if bg(61) > 0 then begin
    l('');
    l('Turns without conquest: ' + i(bg(61)));
    l('Turns without conquest total: ' + i(bg(62)));
  end;
  if bg(61) > 10 then begin
    UTakeSnapshot('>10 turns in a row without conquest');
    m('snapshot taken');
  end;
  if SAlivePlayersCount = 2 then begin
    //UTakeSnapshot('SAlivePlayersCount = 2');
  end;

  ConquestForce(CForce);
  FromTerritory:= 0;
  ToTerritory:= 0;

  // test
  if PTC = 42 then if m2('You have encountered a bug; Click the stop button as quickly as you can after hitting enter to close this message.') then exit;

  if (Army[1] = 12) and (TOwner(14) = PMe) and (TArmies(14) > 1) then begin
    FromTerritory:= 12;
    ToTerritory:= 14;
    Armies:= TArmies(FromTerritory) - 1;
  end;
  if (Army[1] = 10) and (TOwner(9) = PMe) and (TArmies(9) > 1) then begin
    FromTerritory:= 10;
    ToTerritory:= 9;
    Armies:= TArmies(FromTerritory) - 1;
  end;

  // this code only needed if I continue to use finisher code
  if (bg(64) = 100) or (bg(66) = 1) then begin
    MaxArmy:= 0;
    For T:= 1 to 42 do begin
      if TIsMine(T) and (not TIsFront(T)) then begin
        if (TArmies(T) > TArmies(MaxArmy)) and (TArmies(T) > 1) then MaxArmy:= T;
      end;
    end;
    if MaxArmy > 0 then begin
      TT:= TPathToFront(MaxArmy);
      if TT > 0 then begin
        ToTerritory:= TT;
        FromTerritory:= MaxArmy;
        Armies:= TArmies(FromTerritory) - 1;
      end;
    end;
  end;
  bs(66, 0);
  if FromTerritory > 0 then exit;

  { 1: find the blocked in T that can get to the T with the best balance between fewest EA and shortest Path Length}
  MinEA:= 0;
  MinPL:= 0;
  ArmySort(Army);
  For x:= 1 to PTC do begin
    T:= Army[x];
    if (Not TIsFront(T)) and (TArmies(T) >= 10) {and (not AIFD(T))} then begin
      PathToClosestWeakFront(T, TT, WF, PL);
      if (TT > 0) and ( ((TArmies(WF) < MinEA) or (MinEA = 0))
       or ((TArmies(WF) < MinEA + 5) and (PL <= round(double(MinPL)/2))) ) then begin
        MinPL:= PL;
        MinEA:= TArmies(WF);
        FromTerritory:= T;
        ToTerritory:= TT;
        Armies:= TArmies(T) - 1;
        l('');
        m2('1 large army blocked in FT: ' + i(FromTerritory) + ' TT: ' + i(ToTerritory));
        l('');
      end;
    end;
  end;
  
  { 2: Find a small army and combine with a bigger one }
  If FromTerritory = 0 then begin
    For x:= 2 to PTC do begin
      If (TArmies(Army[x]) < 10) and (TArmies(Army[x]) > 1) {and (not AIFD(Army[x]))} then begin
        For y:= x-1 downto 1 do begin
          if TIsBordering(Army[x], Army[y]) then begin
            ToTerritory:= Army[y];
            FromTerritory:= Army[x];
            Armies:= TArmies(FromTerritory) - 1;
          end;
        end;
      end;
    end;
  end;

  { 3: Move to a T that has better attack options }
  If FromTerritory = 0 then begin
    MinEA:= 0;
    Combine:= False;
    For x:= PTC downto 1 do begin
      T:= Army[X];                            // Dont fortify from the T we intentionally occupied
      If TIsFront(T) and (TArmies(T) > 3) and ( not ((bg(72) > 2) and (T = bg(71))) ) {and (not AIFD(Army[x]))} then begin
        TWeakestFront(T, ET, EA);
        if (EA > CForce) and (FromTerritory = 0) then Combine:= True else Combine:= False;
        for B:= 1 to TBordersCount(T) do begin
          BT:= TBorder(T, B);
          if TIsFront(BT) then begin
            TWeakestFront(BT, ET1, EA1);
            if (  ( (EA1 < EA) and (TArmies(BT) > 3) and Combine )
            or ( (EA1 < EA) and (TArmies(BT) < 3) )  )
            and ((EA1 < MinEA) or (MinEA = 0)) then begin
              if combine and (TArmies(BT) > 3) then l('combine');
              ToTerritory:= BT;
              FromTerritory:= T;
              Armies:= TArmies(FromTerritory) - 1;
              MinEA:= EA1;
              l('');
              l('3 fortify to T with less EA TT: ' + i(ToTerritory));
              l('');
            end;
          end;
        end;
      end;
    end;
  end;
  
  { 4: This keeps me from getting trapped behind one large enemy army and my other territories }
  If FromTerritory = 0 then begin
    For x:= 1 to PTC do begin
      if (Army[x] = bg(71)) and (bg(72) > 2) then x:= x + 1;  // Dont fortify from the T we intentionally occupied
      if (TFrontsCount(Army[x]) = 1) and (TBordersCount(Army[x]) > 1)
       and (TArmies(Army[x]) > 1) and (TArmies(TFront(Army[x], 1)) > CForce) {and (not AIFD(Army[x]))} then begin
        PathToClosestWeakFront(Army[x], TT, WF, PL); // in this case it's really PathToClosestWeakerFront
        if (TT > 0) then begin
          FromTerritory:= Army[x];
          ToTerritory:= TT;
          Armies:= TArmies(Army[x]) - 1;
          if (x = 1) and (TArmies(Army[x]) > 40) and (not TIsBordering(TT, TFront(Army[x], 1))) then Armies:= TArmies(Army[x]) - 4;  // leave some behind in case blocking enemy moves away
          l('4 untrap me FT: ' + i(Fromterritory) + ' TT: ' + i(Toterritory));
          exit;
        end;
      end;
    end;
  end;

  If (bg(72) > 2) and (FromTerritory = bg(71)) then begin  // don't fortify away from the T we intentionally occupied
    FromTerritory:= 0;      //   71 - Keeps track of the last territory I conquered
    ToTerritory:= 0;        //   72 - Keeps track of how many times I've attacked the same territory
  end;

  { 5: find any remaining blocked in Ts that can get to the T with the best balance between fewest EA and shortest Path Length}
  If FromTerritory = 0 then begin
    MinEA:= 0;
    MinPL:= 0;
    ArmySort(Army);
    For x:= 1 to PTC do begin
      T:= Army[x];
      if (Not TIsFront(T)) and (TArmies(T) > 1) then begin // only line changed from #1
        PathToClosestWeakFront(T, TT, WF, PL);

        if (TT > 0) and ( ((TArmies(WF) < MinEA) or (MinEA = 0))
         or ((TArmies(WF) < MinEA + 5) and (PL <= round(double(MinPL)/2))) ){ and (not AIFD(T))} then begin
          MinPL:= PL;
          MinEA:= TArmies(WF);
          FromTerritory:= T;
          ToTerritory:= TT;
          Armies:= TArmies(T) - 1;
          l('');
          l('5 large army blocked in FT: ' + i(FromTerritory) + ' TT: ' + i(ToTerritory));
          l('');
        end;
      end;
    end;
  end;

  // 6: backup code for the case when the only enemy Ts left have more armies than the CForce
  if FromTerritory = 0 then begin
    MaxArmy:= 0;
    For T:= 1 to 42 do begin
      if TIsMine(T) and (not TIsFront(T)) then begin
        if (TArmies(T) > TArmies(MaxArmy)) and (TArmies(T) > 1) then MaxArmy:= T;
      end;
    end;
    if MaxArmy > 0 then begin
      TT:= TPathToFront(MaxArmy);
      if TT > 0 then begin
        ToTerritory:= TT;
        FromTerritory:= MaxArmy;
        Armies:= TArmies(FromTerritory) - 1;
      end;
    end;
  end;

  If (bg(72) > 2) and (FromTerritory = bg(71)) then begin  // don't fortify away from the T we intentionally occupied
    FromTerritory:= 0;      //   71 - Keeps track of the last territory I conquered
    ToTerritory:= 0;        //   72 - Keeps track of how many times I've attacked the same territory
  end;

  // only send enough into Australia to take it and no more
  if (FromTerritory = 31) and (ToTerritory = 39) then begin
    CAnalysis(6, PT, PA, ET, EA);
    Armies:= ET + EA - (PA - PT);
    if Armies > TArmies(FromTerritory) - 1 then Armies:= TArmies(FromTerritory) - 1;
    if TArmies(31) > Armies + 3 Then Armies:= Armies + 3;
    If Armies > TArmies(31) then Armies:= TArmies(31);
    if Armies <= 0 then begin
      FromTerritory:= 0;
      ToTerritory:=0;
      Armies:=0;
    end;
  end;

end; // end procedure Fortification

begin
  {
  UMessageOn;
  ULogOn;
  UDialogOn;
  //}
  //USnapShotOn;
end.